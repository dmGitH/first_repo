/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package kriptovasec;

import java.awt.Color;
import java.awt.Cursor;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import static java.lang.Character.getNumericValue;
import static java.lang.Thread.sleep;
import java.util.Arrays;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 *
 * @author dm
 */
public class NewApplication extends javax.swing.JFrame {

    private static final long serialVersionUID = 5408108032201811049L;

    //private static final long serialVersionUID = 1L;

    /**
     * Creates new form NewApplication
     */
    public NewApplication() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jPasswordField1 = new javax.swing.JPasswordField();
        jLabel1 = new javax.swing.JLabel();
        jPasswordField2 = new javax.swing.JPasswordField();
        jButton1 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jCheckBox1 = new javax.swing.JCheckBox();
        jButton2 = new javax.swing.JButton();
        jComboBox1 = new javax.swing.JComboBox<>();
        jComboBox2 = new javax.swing.JComboBox<>();
        jComboBox3 = new javax.swing.JComboBox<>();
        jCheckBox2 = new javax.swing.JCheckBox();
        jComboBox4 = new javax.swing.JComboBox<>();
        jCheckBox4 = new javax.swing.JCheckBox();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jButton5 = new javax.swing.JButton();
        jButton6 = new javax.swing.JButton();
        jPasswordField3 = new javax.swing.JPasswordField();
        jLabel5 = new javax.swing.JLabel();
        jButton7 = new javax.swing.JButton();
        jCheckBox5 = new javax.swing.JCheckBox();
        jButton8 = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        jButton9 = new javax.swing.JButton();
        jButton10 = new javax.swing.JButton();
        jButton12 = new javax.swing.JButton();
        jButton11 = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        list1 = new java.awt.List();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jButton13 = new javax.swing.JButton();
        jComboBox5 = new javax.swing.JComboBox<>();
        jLabel15 = new javax.swing.JLabel();
        jButton14 = new javax.swing.JButton();
        jButton15 = new javax.swing.JButton();
        jCheckBox6 = new javax.swing.JCheckBox();
        jCheckBox7 = new javax.swing.JCheckBox();
        jLabel16 = new javax.swing.JLabel();
        jCheckBox8 = new javax.swing.JCheckBox();
        jLabel17 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jComboBox6 = new javax.swing.JComboBox<>();
        jCheckBox9 = new javax.swing.JCheckBox();
        jComboBox7 = new javax.swing.JComboBox<>();
        jButton16 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        jLabel18 = new javax.swing.JLabel();
        jCheckBox3 = new javax.swing.JCheckBox();
        jButton19 = new javax.swing.JButton();
        list2 = new java.awt.List();
        jCheckBox10 = new javax.swing.JCheckBox();
        jComboBox8 = new javax.swing.JComboBox<>();
        jComboBox9 = new javax.swing.JComboBox<>();
        jCheckBox11 = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Biztonsági törlés és fájl titkosítás                                                                                                                   Kriptova    ");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        jFileChooser1.setDialogType(javax.swing.JFileChooser.CUSTOM_DIALOG);
        jFileChooser1.setApproveButtonText("Megnyitás");
        jFileChooser1.setApproveButtonToolTipText("");
        jFileChooser1.setBackground(new java.awt.Color(0, 0, 0));
        jFileChooser1.setControlButtonsAreShown(false);
        jFileChooser1.setCurrentDirectory(new java.io.File("c:\\"));
            jFileChooser1.setDialogTitle("");
            jFileChooser1.setForeground(new java.awt.Color(255, 153, 0));
            jFileChooser1.setToolTipText("Dupla kattintással válassza ki a fájlt");
            jFileChooser1.setAutoscrolls(true);
            jFileChooser1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
            jFileChooser1.setDragEnabled(true);
            jFileChooser1.setName(""); // NOI18N
            jFileChooser1.setNextFocusableComponent(jPasswordField1);
            jFileChooser1.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jFileChooser1ActionPerformed(evt);
                }
            });

            jPasswordField1.setEditable(false);
            jPasswordField1.setToolTipText("Jelszó: Kódmondat ");
            jPasswordField1.addFocusListener(new java.awt.event.FocusAdapter() {
                public void focusGained(java.awt.event.FocusEvent evt) {
                    jPasswordField1FocusGained(evt);
                }
                public void focusLost(java.awt.event.FocusEvent evt) {
                    jPasswordField1FocusLost(evt);
                }
            });
            jPasswordField1.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jPasswordField1ActionPerformed(evt);
                }
            });
            jPasswordField1.addKeyListener(new java.awt.event.KeyAdapter() {
                public void keyPressed(java.awt.event.KeyEvent evt) {
                    jPasswordField1KeyPressed(evt);
                }
            });

            jLabel1.setBackground(new java.awt.Color(204, 204, 204));
            jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
            jLabel1.setToolTipText("");
            jLabel1.setFocusable(false);

            jPasswordField2.setEditable(false);
            jPasswordField2.setToolTipText("Jelszó: Kódmondat ");
            jPasswordField2.addFocusListener(new java.awt.event.FocusAdapter() {
                public void focusLost(java.awt.event.FocusEvent evt) {
                    jPasswordField2FocusLost(evt);
                }
            });

            jButton1.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jButton1.setText("Kódolás");
            jButton1.setToolTipText("A kódolási folyamat alatt a program nem válaszol.");
            jButton1.setEnabled(false);
            jButton1.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton1ActionPerformed(evt);
                }
            });

            jLabel3.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jLabel3.setForeground(new java.awt.Color(0, 0, 255));
            jLabel3.setText("Fájl:");
            jLabel3.setFocusable(false);

            jTextArea1.setBackground(new java.awt.Color(0, 0, 0));
            jTextArea1.setColumns(20);
            jTextArea1.setFont(new java.awt.Font("Dialog", 0, 14)); // NOI18N
            jTextArea1.setForeground(new java.awt.Color(255, 255, 0));
            jTextArea1.setRows(5);
            jTextArea1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
            jTextArea1.setDoubleBuffered(true);
            jTextArea1.setFocusable(false);
            jScrollPane1.setViewportView(jTextArea1);

            jCheckBox1.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jCheckBox1.setForeground(new java.awt.Color(255, 0, 0));
            jCheckBox1.setText(" Fájl törlése a kódolás után");
            jCheckBox1.setToolTipText("Ha be van jelülve a kódolás elvégzése után az eredeti fájlt  felülírja és törli a program kérdés nélkül!");

            jButton2.setText("Biztonsági törlés");
            jButton2.setToolTipText("A kiválasztott fájlt felülírja utánna törli");
            jButton2.setEnabled(false);
            jButton2.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton2ActionPerformed(evt);
                }
            });

            jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20" }));
            jComboBox1.setToolTipText("pin1  és (pw hossz) indulásnál pwxor");
            jComboBox1.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jComboBox1ActionPerformed(evt);
                }
            });

            jComboBox2.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "0", "1", "2", "3", "4", "5", "6", "7" }));
            jComboBox2.setToolTipText("2-Kódolásmélység- pin2 -indulásnál m.kulcs forgatása");
            jComboBox2.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jComboBox2ActionPerformed(evt);
                }
            });

            jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20" }));
            jComboBox3.setToolTipText("gyakoribb pótkulcs > pin3 - indulásnál mkulcs csúsztatása");
            jComboBox3.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jComboBox3ActionPerformed(evt);
                }
            });

            jCheckBox2.setText("Dekódol");
            jCheckBox2.setEnabled(false);
            jCheckBox2.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox2ActionPerformed(evt);
                }
            });

            jComboBox4.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "20000", "40000", "60000", "80000 ", "100000", "120000", "140000", "160000", "180000", "200000", "220000", "240000", "260000", "280000", "300000", "320000", "340000", "360000", "380000", "400000", "420000", "440000", "460000", "480000", "500000" }));
            jComboBox4.setToolTipText("Buffer-pin4-byte-generalt kulcs byte");
            jComboBox4.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jComboBox4ActionPerformed(evt);
                }
            });

            jCheckBox4.setText("Fájl_Fájl kódolás");
            jCheckBox4.setToolTipText("Fájl-fájl kódolás, kulcsnak a titkositandónál NAGYOBB és később NEM VÁLTOZTATOTT! kulcsfájlt kell megadni !");
            jCheckBox4.setEnabled(false);
            jCheckBox4.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox4ActionPerformed(evt);
                }
            });

            jButton3.setText("Rezet-Mégsem");
            jButton3.setEnabled(false);
            jButton3.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                    jButton3MouseClicked(evt);
                }
            });
            jButton3.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton3ActionPerformed(evt);
                }
            });

            jButton4.setText("Megnyit");
            jButton4.setToolTipText("Létező konténerfájl megnyitása");
            jButton4.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton4ActionPerformed(evt);
                }
            });

            jLabel4.setFont(new java.awt.Font("Dialog", 1, 18)); // NOI18N
            jLabel4.setForeground(new java.awt.Color(0, 0, 204));
            jLabel4.setText("  Titkosítás konténer fájlba");

            jButton5.setText("Lezár");
            jButton5.setToolTipText("Megnyitott konténerfájl lezárása");
            jButton5.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton5ActionPerformed(evt);
                }
            });

            jButton6.setText("Új konténer");
            jButton6.setToolTipText("Új konténerfájl létrehozása");
            jButton6.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton6ActionPerformed(evt);
                }
            });

            jPasswordField3.setBackground(new java.awt.Color(255, 0, 0));
            jPasswordField3.setText("MasterPass+++0");

            jLabel5.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jLabel5.setForeground(new java.awt.Color(51, 0, 0));
            jLabel5.setText("Mesterjelszó");

            jButton7.setText("Beír");
            jButton7.setToolTipText("Jelszó bevitele");
            jButton7.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton7ActionPerformed(evt);
                }
            });
            jButton7.addKeyListener(new java.awt.event.KeyAdapter() {
                public void keyPressed(java.awt.event.KeyEvent evt) {
                    jButton7KeyPressed(evt);
                }
            });

            jCheckBox5.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jCheckBox5.setForeground(new java.awt.Color(0, 51, 51));
            jCheckBox5.setText("Konténer használat be-ki");
            jCheckBox5.setToolTipText("Kapcsolja be ha konténerfájllal akar dolgozni");
            jCheckBox5.setEnabled(false);
            jCheckBox5.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                    jCheckBox5MouseClicked(evt);
                }
            });
            jCheckBox5.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox5ActionPerformed(evt);
                }
            });

            jButton8.setText("Tétel törlése");
            jButton8.setToolTipText("A listában szereplő fájl törlése a konténer elérhető tételei küzül");
            jButton8.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton8ActionPerformed(evt);
                }
            });

            jLabel8.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jLabel8.setText("Tömörítéssel felszabadítható hely:                                ");

            jButton9.setText("Tömörítés");
            jButton9.setToolTipText("Konténerfájl újraírása a törölt tételek nélkül nagy méretü fájl esetén hosszabb időt vehet igénybe");
            jButton9.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton9ActionPerformed(evt);
                }
            });

            jButton10.setText("Dekódolás");
            jButton10.setToolTipText("A listában kijelölt fájl kikódolása a munkakönyvtárba");
            jButton10.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton10ActionPerformed(evt);
                }
            });

            jButton12.setText("Tétel hozzáadása");
            jButton12.setToolTipText("Új fájl felvétele a konténerbe");
            jButton12.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton12ActionPerformed(evt);
                }
            });

            jButton11.setText("Mégsem");
            jButton11.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton11ActionPerformed(evt);
                }
            });

            jLabel7.setForeground(new java.awt.Color(51, 51, 0));
            jLabel7.setText("Konténer neve:");

            jLabel10.setText("Hely: ");

            list1.setBackground(new java.awt.Color(0, 0, 0));
            list1.setForeground(new java.awt.Color(204, 204, 0));
            list1.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                    list1MouseClicked(evt);
                }
            });
            list1.addKeyListener(new java.awt.event.KeyAdapter() {
                public void keyReleased(java.awt.event.KeyEvent evt) {
                    list1KeyReleased(evt);
                }
            });

            jLabel11.setText("Foglalt:");

            jLabel12.setText("Törölt:");

            jLabel6.setText("Konténer mérete:");

            jLabel13.setForeground(new java.awt.Color(51, 0, 0));
            jLabel13.setText("Konténer adatok");

            jLabel14.setText("Maradt:");

            jButton13.setText("Kulcsállomány generálás");
            jButton13.setToolTipText("Fájl-Fájl titkosításhoz random tartalmú kulcs fájlt lehet generálni");
            jButton13.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton13ActionPerformed(evt);
                }
            });

            jComboBox5.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "95 MB", "195 MB", "285 MB", "380 MB", "475 MB", "570 MB", "665 MB", "760 MB", "855 MB", "950 MB" }));
            jComboBox5.setToolTipText("Kulcsfájl mérete. Legyen a kodolandónál nagyobb! Ha nincsen válasszon másik titkosítási módot.");

            jLabel15.setText("Key: ");

            jButton14.setText("Munkakönyvtár");
            jButton14.setToolTipText("Vissza a munkakönyvtárba");
            jButton14.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton14ActionPerformed(evt);
                }
            });

            jButton15.setText("TFV");
            jButton15.setToolTipText("Töröltre jelölt fájlok visszaállítása");
            jButton15.setEnabled(false);
            jButton15.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton15ActionPerformed(evt);
                }
            });

            jCheckBox6.setSelected(true);
            jCheckBox6.setText("Kulcsforgatás");
            jCheckBox6.setToolTipText("Kulcsforgatás kapcsolása");
            jCheckBox6.setEnabled(false);
            jCheckBox6.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox6ActionPerformed(evt);
                }
            });

            jCheckBox7.setSelected(true);
            jCheckBox7.setText("jCheckBox7");
            jCheckBox7.setToolTipText("Tételenkénti kétkulcsos konténer kódolás- ");
            jCheckBox7.setEnabled(false);
            jCheckBox7.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox7ActionPerformed(evt);
                }
            });

            jLabel16.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
            jLabel16.setForeground(new java.awt.Color(102, 0, 0));
            jLabel16.setText("MKey PIN:");

            jCheckBox8.setText("Önmegsemmisítés");
            jCheckBox8.setToolTipText("A Kriptova.jar leállítás után nem lesz többé használható. Legyen róla másolata biztos helyen");
            jCheckBox8.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox8ActionPerformed(evt);
                }
            });

            jLabel2.setText("  Password");

            jTextArea2.setBackground(new java.awt.Color(0, 0, 0));
            jTextArea2.setColumns(20);
            jTextArea2.setForeground(new java.awt.Color(0, 204, 153));
            jTextArea2.setRows(5);
            jTextArea2.setText("Itt rövid, maximum 450 karakter megjegyzést fűzhet, kódolás előtt a fájlhoz.\nAmit, a kodoláskori beállításokkal indítva, a dekódolás bekapcsolásával kiolvashat.");
            jTextArea2.setToolTipText("");
            jTextArea2.setAutoscrolls(false);
            jTextArea2.setMaximumSize(new java.awt.Dimension(713, 2147483647));
            jTextArea2.setMinimumSize(new java.awt.Dimension(713, 32));
            jTextArea2.addKeyListener(new java.awt.event.KeyAdapter() {
                public void keyPressed(java.awt.event.KeyEvent evt) {
                    jTextArea2KeyPressed(evt);
                }
            });
            jScrollPane2.setViewportView(jTextArea2);

            jComboBox6.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Fájl Törlés\t", "Szabadhely Tö", "Csoportos Tör", "Gyors könyvt. Titk", "Tömeges Titk." }));
            jComboBox6.setToolTipText("Törlési mód beállítása");
            jComboBox6.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jComboBox6ActionPerformed(evt);
                }
            });

            jCheckBox9.setText("Rövid üzenet");
            jCheckBox9.setToolTipText("Titkosított szöveges üzenet létrehozása, időkorláttal ");
            jCheckBox9.setEnabled(false);
            jCheckBox9.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jCheckBox9ActionPerformed(evt);
                }
            });

            jComboBox7.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "1 nap", "2 nap", "3 nap", "4 nap", "5 nap", "6 nap", "7 nap", "8 nap", "9 nap", "10 nap" }));
            jComboBox7.setToolTipText("A kódolt szöveges üzenet fájl a beállított napig olvasható a létrehozásától számítva");
            jComboBox7.setEnabled(false);

            jButton16.setText("Frissítés");
            jButton16.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton16ActionPerformed(evt);
                }
            });

            jTextPane1.setBackground(new java.awt.Color(153, 0, 153));
            jTextPane1.setForeground(new java.awt.Color(255, 255, 0));
            jTextPane1.setToolTipText("Húzza ide a konténerhez adandó fájlok mappáját");
            jTextPane1.setAutoscrolls(false);
            jTextPane1.setFocusCycleRoot(false);
            jTextPane1.setFocusable(false);
            jTextPane1.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseEntered(java.awt.event.MouseEvent evt) {
                    jTextPane1MouseEntered(evt);
                }
            });
            jScrollPane3.setViewportView(jTextPane1);

            jLabel18.setText("Ide lehet húzni a mappákat");

            jCheckBox3.setText("Mindet");
            jCheckBox3.setToolTipText("");

            jButton19.setText("Hibajavitas");
            jButton19.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jButton19ActionPerformed(evt);
                }
            });

            list2.setBackground(new java.awt.Color(0, 0, 0));
            list2.setFont(new java.awt.Font("Arial Rounded MT Bold", 1, 14)); // NOI18N
            list2.setForeground(new java.awt.Color(51, 255, 255));
            list2.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                    list2MouseClicked(evt);
                }
            });
            list2.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
                public void mouseMoved(java.awt.event.MouseEvent evt) {
                    list2MouseMoved(evt);
                }
            });

            jCheckBox10.setSelected(true);
            jCheckBox10.setText("Várjon írásra percig:");
            jCheckBox10.setToolTipText("");

            jComboBox8.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "1 min", "3 min", "5 min", "10 min", "30 min", "1 óra", "2 óra", "3 óra" }));
            jComboBox8.setSelectedIndex(4);
            jComboBox8.setToolTipText("Állítsa be hogy a program mennyi ideig próbálkozzon a konténer írásával, ha az foglalt");

            jComboBox9.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Dátum szerint", "Név szerint", "Méret szerint" }));
            jComboBox9.setToolTipText("A konténerben lévő tételek megjelenítési sorrendje");
            jComboBox9.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    jComboBox9ActionPerformed(evt);
                }
            });

            jCheckBox11.setText("Feltöltés, letöltés után kilép");

            javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
            getContentPane().setLayout(layout);
            layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(8, 8, 8)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 408, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jButton2)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jButton3)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                            .addComponent(jButton14)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addGroup(layout.createSequentialGroup()
                                                    .addComponent(jCheckBox9)
                                                    .addGap(5, 5, 5))
                                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                    .addComponent(jComboBox7, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                        .addComponent(jCheckBox6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jCheckBox2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                    .addGap(2, 2, 2))
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(13, 13, 13)
                                    .addComponent(jScrollPane2)
                                    .addGap(13, 13, 13))
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(200, 200, 200)
                                    .addComponent(jCheckBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(31, 31, 31)
                                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(18, 18, 18)
                                    .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(18, 18, 18)
                                    .addComponent(jComboBox3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(18, 18, 18)
                                    .addComponent(jComboBox4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(0, 0, Short.MAX_VALUE))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addGap(0, 0, Short.MAX_VALUE)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addComponent(jLabel15, javax.swing.GroupLayout.PREFERRED_SIZE, 565, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jCheckBox8)
                                            .addGap(8, 8, 8))
                                        .addComponent(jFileChooser1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 746, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addComponent(jComboBox6, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(18, 18, 18)
                                            .addComponent(jPasswordField1, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 74, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jPasswordField2, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(29, 29, 29)
                                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 228, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addGap(0, 0, Short.MAX_VALUE)
                            .addComponent(jCheckBox4, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(604, 604, 604))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addComponent(jLabel16, javax.swing.GroupLayout.PREFERRED_SIZE, 244, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(7, 7, 7))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 730, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(16, 16, 16)))))
                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                    .addComponent(list2, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(8, 8, 8)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jButton15, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 181, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jButton13)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jComboBox5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jCheckBox7, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jCheckBox3, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButton10, javax.swing.GroupLayout.PREFERRED_SIZE, 115, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButton12)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButton11, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButton8)))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(list1, javax.swing.GroupLayout.PREFERRED_SIZE, 553, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(13, 13, 13)))
                        .addGroup(layout.createSequentialGroup()
                            .addGap(14, 14, 14)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addComponent(jLabel18, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(44, 44, 44))
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addComponent(jCheckBox10)
                                            .addGap(4, 4, 4)
                                            .addComponent(jComboBox8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(12, 12, 12)))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jButton19)
                                        .addComponent(jCheckBox11, javax.swing.GroupLayout.PREFERRED_SIZE, 186, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGroup(layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addGroup(layout.createSequentialGroup()
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                                .addComponent(jLabel5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                    .addGap(6, 6, 6)
                                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                                        .addGroup(layout.createSequentialGroup()
                                                            .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                            .addComponent(jButton5, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                            .addComponent(jButton6))
                                                        .addComponent(jScrollPane3))))
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jCheckBox5, javax.swing.GroupLayout.PREFERRED_SIZE, 178, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(layout.createSequentialGroup()
                                            .addGap(0, 0, Short.MAX_VALUE)
                                            .addComponent(jLabel4)
                                            .addGap(124, 124, 124)
                                            .addComponent(jLabel17, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGap(21, 21, 21))
                                .addGroup(layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(jLabel7, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                    .addComponent(jPasswordField3, javax.swing.GroupLayout.PREFERRED_SIZE, 208, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                    .addGap(18, 18, 18)
                                                    .addComponent(jButton7, javax.swing.GroupLayout.PREFERRED_SIZE, 89, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                    .addGap(6, 6, 6)
                                                    .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 383, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                            .addGap(0, 0, Short.MAX_VALUE)))
                                    .addGap(18, 18, 18)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jLabel13)
                                        .addComponent(jLabel14, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(jButton16, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jButton9, javax.swing.GroupLayout.DEFAULT_SIZE, 118, Short.MAX_VALUE))
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                            .addComponent(jLabel11, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jLabel10, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 108, Short.MAX_VALUE)
                                            .addComponent(jLabel12, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addComponent(jComboBox9, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))
            );
            layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addGap(0, 0, Short.MAX_VALUE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(list2, javax.swing.GroupLayout.PREFERRED_SIZE, 850, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel15, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jCheckBox8))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jFileChooser1, javax.swing.GroupLayout.PREFERRED_SIZE, 263, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jPasswordField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jPasswordField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jLabel2)
                                            .addComponent(jComboBox6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addComponent(jLabel1))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                            .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jButton14, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jCheckBox2)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jCheckBox6))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jCheckBox9)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jComboBox7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGap(18, 18, 18)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel3)
                                        .addComponent(jLabel16))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 313, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGap(3, 3, 3))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addComponent(jCheckBox11)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 0, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jLabel17)
                                        .addComponent(jButton16)
                                        .addComponent(jButton19)))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(jCheckBox10)
                                        .addComponent(jComboBox8, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jLabel18)))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(6, 6, 6)
                                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jButton5, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jButton6, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 19, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jPasswordField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jButton7, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel7)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel8))
                                .addGroup(layout.createSequentialGroup()
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jButton9)
                                    .addGap(18, 18, 18)
                                    .addComponent(jCheckBox5)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel13)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel10)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel11)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel12)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel14)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                    .addComponent(jComboBox9, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jButton10)
                                .addComponent(jButton12)
                                .addComponent(jButton11)
                                .addComponent(jButton8)
                                .addComponent(jCheckBox3))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(list1, javax.swing.GroupLayout.PREFERRED_SIZE, 520, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addGap(4, 4, 4)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel6)
                                .addComponent(jButton13)
                                .addComponent(jComboBox5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jButton15)
                                .addComponent(jCheckBox7)))
                        .addGroup(layout.createSequentialGroup()
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jCheckBox1)
                                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jComboBox3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGroup(layout.createSequentialGroup()
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(jCheckBox4))
                        .addGroup(layout.createSequentialGroup()
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jComboBox4, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            );

            list1.getAccessibleContext().setAccessibleDescription("");

            pack();
        }// </editor-fold>//GEN-END:initComponents

    String pw="";
    DataInputStream kodolando;
    DataInputStream kulcs;
    DataOutputStream kodolt;
    RandomAccessFile doboz = null;
    RandomAccessFile sor = null;
    boolean Inputnyitott=false;
    boolean Outputnyitott=false;
    int nyitasellenor1=0;
    int nyitasellenor2=0;
    int rand;
    long thossza;
    String kodoltneve;
    String originname;
    boolean visszafejt=false;
    long bajt;
    int kihagy=0;
    int fejlec=0;
    String kodnev;
    boolean kulcsolt=false;
    File kulcs1;
    int ujkulcshossz;
    byte [] kriptovakey;
    byte [] kriptovakeyor;
    byte [] kontenerkey;
    int logszamlalo=0;
    boolean torol=false;
    boolean kontener=false;
    long mestercrc=0;
    boolean indulasellenor=true;
    boolean kontenergeneralas=false;
    int inditasproba=0;
    boolean kontenernyitas=false;
    boolean [] kontflag;
    long [] konpoint;
    char [] filenevkiolvaso;
    String [] kontfajlnev;
    boolean hozzaad=false;
    int szamol=0;//kontfajnevet
    int kny=0;
    boolean listaboltorol=false;
    long fejlecpointer;
    long felszabadithatohely=0;
    int tj=0; //törlésre jelölt
    boolean kkopen=false;
    String logtxt;
    long kezdet,veg;
    boolean mesterkucshoztartozik=true;
    boolean tomorithet=false;
    boolean pinvaltas=false;
    //byte [][] kulcstomb; // 10 25
    byte [][][] kulcssegedtomb; //11 db 1 5 5
    //boolean kulcsforgatas=false;
    public String kontenernev="false";
    String kontenerhelye;
    long [] sorbanall;
    boolean forgatasbe=false;
    long pinor=0;
    int kontfilenevhossz=0;
    String kulcsnev;
    boolean kfbe=false;
    int logbk=0;
    String nyerseredetinev;
    boolean roviduzenet=false;
    long szabadhely;
    File dobozszabadhely;
    boolean szemafor=true;
    long verzio;
    int kpin1,kpin2,kpin3,kpin4;
    Thread szal1,szal2;
    int helyreallit=0;
    String javitando,javito;
    int osszdb=0;
    long osszmeret=0;
    long kimaradmeret=0;
    int kimaradtdb=0;
    boolean csakegyszer=true;
    String jta2="";
    boolean voltfoglalt=false;
    boolean bedobott=false;
    boolean idxkodolas=false;
    int enyem;
    boolean sornyitott=false;
    boolean ki=true; //a tomeges kódolás utáni konténerhez adnál kivenni a várólistából a kódolás végéig
    int sorbanalhatnak=12;
    long [] regiek;
    boolean hiba=false;
    boolean belepo=true;
    
    
    
    private void jFileChooser1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFileChooser1ActionPerformed
        
        if(helyreallit==1){
            jTextArea1.append("\n\nHa kiválasztotta a konténert nyomja meg újra a Hibajavítás gombot.\n"); 
            
            return;
        }else if(helyreallit==2){
            jTextArea1.append("\n\nHa kiválasztotta a javító állományt nyomja meg újra a Hibajavítás gombot.\n"); 
            return;
        }
        
        if(roviduzenet){
            if(!jCheckBox2.isSelected()){jTextArea1.append("\nRövid üzenet módban van. Kapcsolja ki vagy kapcsolja be a dekódolást");return;}
            rovkod(3);
            kursor(0);
            roviduzenet=false;
            jCheckBox2.setSelected(false);
            jCheckBox9.setSelected(false);
            jComboBox7.setEnabled(false);
            jCheckBox4.setEnabled(true);
            jButton1.setText("Kódolás");
            jPasswordField1.setBackground(Color.white);
            jPasswordField2.setBackground(Color.white);
            jPasswordField1.setText("");
            jPasswordField2.setText("");

            return;
        
        }
        
        jTextArea2.setEditable(true);
        jTextArea1.setText("");
            //fokulcsnyitás
        if(!kkopen || !jButton1.isEnabled()){
            kkopen=true;
            logkeynyit();
            return;
            
        }
        
         //kontenernyitás
        if(kontenernyitas && jCheckBox5.isSelected()){
            kny++;
            if(kny==1){kontenertnyit();jLabel7.setText("Neve:"+jFileChooser1.getSelectedFile().getName()); }
            if(hozzaad){
                try {
                    if(sorbaall());
                    else{
                        hozzaad=false;
                        return;
                    }
                } catch (IOException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                kontenerhezad();
                sorbolki();
                if(jCheckBox11.isSelected()){
                    kontenerlezar();
                    System.exit(0);
                
                }
                
                try {
                    list1.removeAll();
                    doboz.seek(fejlecpointer);
                    kontfejlecbeolvas();
                } catch (IOException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                
                hozzaad=false;
                return;
            }
            //kontenernyitas=false;
            
            return;
        
        }else if(jCheckBox5.isSelected())return;
        //fájlal titkosítás
        if(jCheckBox4.isSelected()){
            Kulcsfajlnyitas();
            jCheckBox4.setSelected(false);
            return;
        }
        //normál jelszavas szimpla fájl 
        if(Inputnyitott){streamclos1();Inputnyitott=false;}
        //String ellenor;
        try {
            // TODO add your handling code here:Fájl kiválasztva megnyitva 
            
            kodolando = new DataInputStream(new FileInputStream(jFileChooser1.getSelectedFile()));
            
            if(jCheckBox2.isSelected()){
            
                kodnev = jFileChooser1.getSelectedFile().getName();
                
                //int kodnevhossz = kodnev.length();
                if(kulcsolt){ //más fájjlal titkosítottnál
                    jTextArea1.append("\nIndíthatja a dekódolást");
                    String mihez=kodnev;
                    kodoltneve=mihez.replace("kripta",".");
                    int kodoltnevhossz=kodoltneve.indexOf("_+_");
                    kodoltneve=kodoltneve.substring(0, kodoltnevhossz);
                    
                }else {
                    kodoltneve="";
                    try {
                        char [] nevkiolvaso = new char[100];
                        for(int i=0;i<100;i++){
                            nevkiolvaso[i]=' ';
                            nevkiolvaso[i]=kodolando.readChar();
                            nevkiolvaso[i]= (char) ((char) (nevkiolvaso[i]^kriptovakey[i])^pinor);
                            kodoltneve=kodoltneve+String.valueOf((char)nevkiolvaso[i]);
                        }
                        int a=0;
                        nevkiolvaso = new char[500];
                        for(int i=0;i<500;i++){
                            nevkiolvaso[i]=' ';
                            nevkiolvaso[i]=kodolando.readChar();
                            nevkiolvaso[i]= (char) ((char) (nevkiolvaso[i]^kriptovakey[a])^pinor);
                            a++;if(a>kriptovakey.length-1)a=0;
                            jTextArea1.append(String.valueOf((char)nevkiolvaso[i]));
                            if((i+1)%90==0)jTextArea1.append("\n");
                        }
                         
                    } catch (IOException ex) {
                        jTextArea1.append("\nEz a fájl nem ezzel a mesterkulccsal, vagy pinbeállításokkal kódolt.");
                        jLabel1.setText("          Válassza ki a fájlt");
                        jPasswordField1.setBackground(Color.white);
                        jPasswordField2.setBackground(Color.white);
                        jTextArea1.setForeground(Color.getHSBColor(generator(), generator(), generator()));
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        return;
                    }
                    Long pinorellenor = null;
                    try {
                        pinorellenor=kodolando.readLong();
                    } catch (IOException ex) {
                        jTextArea1.append("\nEz a fájl nem ezzel a mesterkulccsal, vagy pinbeállításokkal kódolt.");
                        jLabel1.setText("          Válassza ki a fájlt");
                        jPasswordField1.setBackground(Color.white);
                        jPasswordField2.setBackground(Color.white);
                        jTextArea1.setForeground(Color.getHSBColor(generator(), generator(), generator()));
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        return;
                    }
                    if(pinorellenor!=pinor){
                        jTextArea1.append("\nEz a fájl nem ezzel a mesterkulccsal, vagy pinbeállításokkal kódolt.");
                        jLabel1.setText("          Válassza ki a fájlt");
                        jPasswordField1.setBackground(Color.white);
                        jPasswordField2.setBackground(Color.white);
                        jTextArea1.setForeground(Color.getHSBColor(generator(), generator(), generator()));
                        return;
                    }
                     String mihez=kodoltneve;
                   
                    int kodoltnevhossz=kodoltneve.indexOf("_+_");
                   
                    if(kodoltnevhossz>0){kodoltneve=kodoltneve.substring(0, kodoltnevhossz);
                    jTextArea1.append("\nFájl eredeti neve: "+kodoltneve);
                    int parametervege=mihez.indexOf("?");
                    int parametereleje=kodoltneve.length();
                    mihez=mihez.substring(parametereleje+3, parametervege);
                    jTextArea1.setForeground(Color.yellow);
                    jTextArea1.setBackground(Color.black);
                    mihez=mihez.replace("_","   ");}
                    jTextArea1.append("\n\nFájl kódolás paraméterei, jelszóhossz, jelszó emlékeztető, pin 1-2-3-4:\n\t\t"+mihez);
                }//ha jelszavas
            
            }
            
            //jTextArea1.append("\nFájl: Input Stream megnyitva");
            jTextArea2.setText("");
            File kijelolt;
            kijelolt = new File(jFileChooser1.getSelectedFile().getAbsolutePath());
            thossza=kijelolt.length();
            jTextArea1.append("\nFájl hosssza: "+String.valueOf((thossza)/1024/1024)+" Mbájt");
            jTextArea1.append("\nFájl hosssza: "+String.valueOf((thossza)/1024)+" kbájt");
            if(!jCheckBox2.isSelected())jTextArea1.append("\nBeírhatja a megjegyzést, beállíthatja a PINT és megadhatja a jelszót vagy választhat másik fájlt");
            nyitasellenor1++;
            jLabel3.setText(jFileChooser1.getSelectedFile().getName()+" Kódolásra, törlésre megnyitva :"+String.valueOf(nyitasellenor1));
            Inputnyitott=true;
            if(!kulcsolt){
                jLabel1.setText("< Írjon be jelszót");
                jLabel1.setForeground(Color.red);
                jPasswordField1.setBackground(Color.red);
            }
            else {
                jLabel1.setText("Indítsa a kódolást");
                jLabel1.setForeground(Color.black);
                
                jTextArea1.append("\nIndíthatja a kódolást");
            }
            if(!kulcsolt)jPasswordField1.setEditable(true);
          
        } catch (FileNotFoundException ex) {
            jLabel3.setText("Fájl: Kódolásra megnyitása nem sikerült");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jFileChooser1ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
       //szal1.start();
       if(roviduzenet){
            
            if(jCheckBox2.isSelected()){//dekódol ág
                if(!vanjelszo())return;
                
                rovkod(2);
                roviduzenet=false;
                return;
            }else{//kódol ág
                if(!vanjelszo())return;
                rovkod(1);
                jTextArea2.setText("");
            }
            roviduzenet=false;
            jCheckBox4.setEnabled(true);
            jCheckBox9.setSelected(false);
            jComboBox7.setEnabled(false);
             jButton1.setText("Kódolás");
            return;
        }
        jTextArea2.setEditable(true);
        jPasswordField1.setBackground(Color.white);
        jPasswordField2.setBackground(Color.white);
        if(kontener){
            jTextArea1.append("\nKonténer funkció bekapcsolva, kapcsolja ki fájlt akar kódolni.");
            jPasswordField1.setBackground(Color.white);
                        jPasswordField2.setBackground(Color.white);
            return;
            
        }
        if(kulcsolt){
            
            if(!jCheckBox2.isSelected()){
                kodoltneve=jFileChooser1.getSelectedFile().getName()+"_kriptova."+String.valueOf(pinor);//
            }else{
                int index1=kodoltneve.indexOf("_kriptova");
                if(index1>0)kodoltneve=kodoltneve.substring(0, index1);
                
            }
            jTextArea1.append("\nFájl eredeti neve: "+jFileChooser1.getSelectedFile().getName()+"\n");
            jTextArea1.append("Fájl eredeti helye: "+jFileChooser1.getSelectedFile().getPath()+"\n");
            jTextArea1.append("Fájl kodneve: "+kodoltneve+"\n");
            
            
            Calendar cal = Calendar.getInstance();
            jTextArea1.append("\nKezdési idő: "+cal.getTime());
            jPasswordField1.setText("");
            jPasswordField2.setText("");
            //jProgressBar1.setValue(1);
            jTextArea1.setBackground(Color.RED);
            jTextArea1.setForeground(Color.black);
            
            try {
                kulccsal();
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            kulcsolt=false;
            jTextArea1.setBackground(Color.yellow);
            jTextArea1.setForeground(Color.black);
            jLabel1.setForeground(Color.black);
            jLabel1.setText("          Válassza ki a fájlt");
             jFileChooser1.rescanCurrentDirectory();
            return;
        }
        
        //byte [] buffer;
        //int buf = (jComboBox4.getSelectedIndex()+1)*10;
        //buffer = new byte[buf];
       
        if("".equals(pw)){
            jTextArea1.append("\n Nincsen megadva jelszó...");
            jTextArea1.setBackground(Color.black);
            jTextArea1.setForeground(Color.yellow);
             return;
        }
        kihagy=jComboBox1.getSelectedIndex();
        bajt = thossza;
        //adatgyujtes
        //jTextArea1.setText("");
        long tol;
         Calendar cal = Calendar.getInstance();
        tol = cal.getTimeInMillis();
        jTextArea1.append("\nFájl eredeti neve: "+jFileChooser1.getSelectedFile().getName()+"\n");
        jTextArea1.append("Fájl eredeti helye: "+jFileChooser1.getSelectedFile().getPath()+"\n");
        jTextArea1.append("Fájl kodneve: "+kodoltneve+"\n");
        jTextArea1.append("Fájl méret: "+String.valueOf(bajt/1024/1024)+" MB \n");
        jTextArea1.append("\nKezdési idő: "+cal.getTime());
        //pw szamsorrá alakítása
        char [] jsz;
        byte [] pwint;
        int pwhossz;
        pwhossz=pw.length();
        int regihossz=pwhossz;
        pwhossz=pwhossz*((jComboBox1.getSelectedIndex()+1)*20);//megnövelelem a beírt jelszót a 20*osára
        
        
        
       
        jsz = new char[pwhossz];
        pwint= new byte[pwhossz];
        //if(jCheckBox6.isSelected() && !forgatasbe)kulcsforgatas(); // ne keljen a kf-es állományok miatt ujraindítani a programot
        //jTextArea1.append("Jelszohossz: " + String.valueOf(pwhossz) + "\n");
        int valto=0;
        int kkh=0;
        for(int i=0;i<pwhossz;i++){
           if(regihossz+1>valto)valto=0;
           jsz[i]=(char) pw.charAt(valto);//stringből char tömbbe
           pwint[i]=(byte) getNumericValue(jsz[i]);//char tömbből int tömbbe
           if(kriptovakey.length-1>kkh)kkh=0;
           pwint[i]=(byte) ((byte) ((pwint[i]^kriptovakey[kkh])+i)^pwint[i]+pwhossz);
           //jTextArea1.append(String.valueOf(pwint[i])+".");
           //jsz[i]='.';
           valto++;
        }
       
        
        pw="";
        
        
         try {

            //kimenet nyitása
            File kodolthelye = new File("kodolt");
            File dekodolthelye = new File("dekodolt");
            dekodolthelye.mkdir();
            kodolthelye.mkdir();
            
            kodolt = (!jCheckBox2.isSelected()) ? new DataOutputStream(new FileOutputStream("kodolt\\"+String.valueOf(tol))) : new DataOutputStream(new FileOutputStream("dekodolt\\"+kodoltneve));
            jTextArea1.append("\n Kódolandó fájl megnyitva");
            
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            jTextArea1.append("\n Kódolandó fájl megnyitása sikertelen");
        }
        
        if(jCheckBox2.isSelected()){//kodoltneve+=" - visszafejtése: "+cal.getTimeInMillis(); //ha visszfejt akkor már kész a neve a logbol();
            
        
        }else {
            //kodoltneve=String.valueOf(tol)+"^^"+kodoltneve; 
            int kodoltnevehossz=100;//=kodoltneve.length();
            char [] kodoltnevebyte = new char[kodoltnevehossz];
            for(int i=0;i<kodoltnevehossz;i++){
                kodoltnevebyte[i]=' ';
                if(i<kodoltneve.length()){
                    kodoltnevebyte[i]=kodoltneve.charAt(i);
                    kodoltnevebyte[i]=(char) ((char) (kodoltnevebyte[i]^kriptovakey[i])^pinor);
                }
                else kodoltnevebyte[i]=(char) ((char)(kodoltnevebyte[i]^kriptovakey[i])^pinor);
                try {
                    kodolt.writeChar(kodoltnevebyte[i]);
                } catch (IOException ex) {
                    jTextArea1.append("\nFejléc: írás hiba KFI1");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            
            int a=0;
            kodoltnevebyte = new char[500];
            if(jCheckBox6.isSelected()){
                jTextArea2.append("\nKulcsforgatással kódolt");
            }else jTextArea2.append("\nNem kulcsforgatással kódolt");
             for(int i=0;i<500;i++){
                kodoltnevebyte[i]=' ';
                if(i<jTextArea2.getText().length()){
                    kodoltnevebyte[i]=jTextArea2.getText().charAt(i);
                    kodoltnevebyte[i]=(char) ((char) (kodoltnevebyte[i]^kriptovakey[a])^pinor);
                }
                else kodoltnevebyte[i]=(char) ((char)(kodoltnevebyte[i]^kriptovakey[a])^pinor);
                a++;if(a>kriptovakey.length-1)a=0;
                try {
                    kodolt.writeChar(kodoltnevebyte[i]);
                } catch (IOException ex) {
                    jTextArea1.append("\nFejléc: írás hiba KFI1");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
             jTextArea2.setText("");
            try {
                kodolt.writeLong(pinor);
            } catch (IOException ex) {
                jTextArea1.append("\nFejléc: írás hiba KFI2");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        byte  [] ujkulcs;
        //mikro fajlokhoz
        if (bajt<20000)ujkulcs = pwint; //kis fájlnál a pw hossza a kulcs hossza
        else ujkulcs =new byte[(jComboBox4.getSelectedIndex()+1)*20000];
        
        ujkulcshossz=ujkulcs.length;
        if(bajt<ujkulcshossz){ //ha túl nagy a buffer leveszem a fájl méret alá
            ujkulcshossz=20000;
            ujkulcs =new byte[ujkulcshossz]; //ujradefiniálom a kulcstömb méretét
        }
        
        //ide kerülhetne egy kulcsérték generálás a pw hosszabbítására és annak a visszafejtéskori kiolvasása 
        if(jCheckBox2.isSelected() && bajt>ujkulcshossz){
                //visszaolvasni a kulcsértéket a kodolandóbol 
                              
                   try {
                       kodolando.read(ujkulcs);
                                
                    } catch (IOException ex) {
                        jTextArea1.append("\n Kulcs olvasási hiba");    
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                                 
            
                
        }
        else if(!jCheckBox2.isSelected() && bajt>ujkulcshossz) {
                //új kulcsértéket generálni
                              
                
             
                for(int i=0;i<ujkulcshossz;i++){
                    
                    ujkulcs[i]=generator();
                   
                }
               
                try {
                    kodolt.write(ujkulcs);
                } catch (IOException ex) {
                    jTextArea1.append("ujkulcs írás hiba");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
             
            
        }
        
        try {
            //pw és pw hossz;
            int kkl=kriptovakey.length;
            int kkh2=0;//mesterkulcsindex
            int merce2=jComboBox2.getSelectedIndex();
            int pin3=jComboBox3.getSelectedIndex()+1;
            //byte [] tobbkulcs;
            //tobbkulcs=new byte[ujkulcshossz];
            int kelujkulcs=0;
            byte [] olvasint = new byte[ujkulcshossz];
            byte [] atirint = new byte[ujkulcshossz];
                
            int a;
            byte [] seged;
            seged=new byte [pwhossz];
               
            long vanmeg=0;
            long lepesszam=51L;
            long mikorlepni=bajt/51L;
            long vanbajt=bajt;
            while(kodolando.available()>0){
                
                if(vanbajt/mikorlepni==lepesszam){
                        
                            list2.add("V");
                            list2.select(list2.getItemCount()-1);
                           lepesszam--;
                           if(lepesszam<0)list2.removeAll();
                }
               vanbajt=vanbajt-ujkulcshossz;
           
                if(kodolando.available()>ujkulcshossz){
                    
                    //pót segégkulcsok beépített kulcsok
                    if(!jCheckBox2.isSelected()){
                        if(kelujkulcs>pin3*100){
                            for(int l=0;l<ujkulcshossz;l++){
                                ujkulcs[l]=generator();
                                kodolt.writeByte(ujkulcs[l]);
                            }
                            kelujkulcs=0;
                        }
                    
                    }else{
                        if(kelujkulcs>pin3*100){
                            for(int l=0;l<ujkulcshossz;l++){
                                
                                ujkulcs[l]=kodolando.readByte();
                            }
                            kelujkulcs=0;
                        }
                    }
                    vanmeg=kodolando.available();
                    if(!jCheckBox6.isSelected()){
                      
                                int max=pwhossz-1;
                                int min=0;

                                for(int i=0;i<pwhossz;i++){

                                    seged[max]=(byte) (pwint[i]^vanmeg);
                                    seged[min]=(byte) (pwint[++i]^vanmeg);
                                    max--;
                                    min++;
                                }
                        System.arraycopy(pwint, 0, seged, 0, pwhossz);
                    }
                        kodolando.read(olvasint); //jelszohosszal pufferelt ág
                        kelujkulcs++;
                       
                        
                        int max1=ujkulcshossz-1;
                        int min1=0;
                        seged=new byte[ujkulcshossz]; 
                        
                        for(a=0;a<ujkulcshossz;a++){
                             int merce=0;
                             int beirt=0;
                          
                             
                           
                                 do{//kódolásmélység
                                     
                                     if(beirt>pwhossz-1)beirt=0;
                                     if(kkh2>kkl-1){
                                         
                                         kkh2=0;
                                         
                                         
                                     }
                                     if(jCheckBox6.isSelected()){
                                        
                                         
                                         if(a%2==0)atirint[a]=(byte) ((byte)  ~olvasint[a]^kriptovakey[kkh2]+ujkulcs[a]);
                                         else atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^kriptovakey[kkh2]);
                                         
                                        
                                                
                                     }
                                     else {
                                         
                                       if(a%2==0)atirint[a]=(byte) ((byte)  ~olvasint[a]^kriptovakey[kkh2]+ujkulcs[a]);
                                         else atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^kriptovakey[kkh2]);
                                         
                                         
                                         
                                     }
                                     beirt++;
                                     merce++;
                                     kkh2++;
                                     
                                 }while(merce<merce2);
                                 
                                 if(jCheckBox6.isSelected()){
                                                                     
                                     if(((a)%kkh2+13)==0)kulcsforgatas3();
                                     else  if(((a)%beirt+7)==0)kulcsforgatas2();
                                     else if(((a)%kelujkulcs*2)==0)kulcsforgatas();
                                 }
                                 if(jCheckBox2.isSelected())ujkulcs[a]=(byte) (olvasint[a]^pwint[beirt]);//beirt és felhosszabbított pw-wel ráxorzok
                                 else ujkulcs[a]=(byte) (atirint[a]^pwint[beirt]);
                             
                               
                         
                             if(jCheckBox6.isSelected()){    //generált kulcs forgatása
                                    seged[max1]=(byte) (ujkulcs[a]);
                                    if(a<ujkulcshossz-2)seged[min1]=(byte) (ujkulcs[a+1]);
                                    else seged[min1]=ujkulcs[a-1];
                                    max1--;
                                    min1++;
                            }
                                    
                        }
                         
                         if(jCheckBox6.isSelected())System.arraycopy(ujkulcs, 0, seged, 0, ujkulcshossz);
                         kodolt.write(atirint);
                    
                }
                else { //bájtonkénti ág ha már kevés van hátra puffernél kisebb maradék
                        kkh2=0;//mesterkulcsindex
                        kkl=kriptovakey.length;
                        for(a=0;a<ujkulcshossz;a++){
                            int beirt=0;
                            try{
                                olvasint[a]=kodolando.readByte();
                            } catch (IOException ex){
                                 jTextArea1.append("\n A fájl olvasása befejeződött");
                                a=pwhossz;
                                 break;
                               //Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                               
                            }
                            int merce=0;
                            do{//kódolásmélység
                                if(beirt>pwhossz-1)beirt=0;
                                if(kkh2>kkl-1){
                                      
                                      kkh2=0;
                                      if(jCheckBox6.isSelected()){
                                          kulcsforgatas();
                                          
                                      }
                                  }

                               if(jCheckBox6.isSelected()) atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^kriptovakey[kkh2]);
                                  else {
                                      atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^pwint[beirt]);
                                     
                                      atirint[a]=(byte) ((byte) ((byte) (atirint[a])^kriptovakey[kkh2])^ujkulcs[a]);
                                   }        
                                     beirt++;
                                    merce++;
                                    kkh2++;
                                
                            }while(merce<merce2);
                        //kimenet írása
                        try{
                            kodolt.writeByte(atirint[a]);
                        } catch (IOException ex) {
                            jTextArea1.append("\n "+kodoltneve+" fájl írás hiba");
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
            
                } 
                            
            }
            System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length); //jLabel4.setText("Fajl:" +String.valueOf(jsz));
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            kodolt.close();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
       
        if(jCheckBox1.isSelected()){
            try {
                ftorol();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        if(Inputnyitott)streamclos1();
        if(Outputnyitott)streamclos2();
        jTextArea1.setBackground(Color.green);
        jTextArea1.setForeground(Color.black);
        jCheckBox2.setEnabled(true);
        cal = Calendar.getInstance();
        long ig = cal.getTimeInMillis();
        
        long eredm=ig-tol;
        jTextArea1.append("\nBefejezve : "+cal.getTime());
        jTextArea1.append("\nVégrehajtási idő sec : "+String.valueOf(eredm/1000));
        //double speed;
        double mb = (bajt/1024/1024);
        jTextArea1.append("\nEredmény : "+String.valueOf(mb/(eredm/1000))+" MB/sec");
      /*  if(jCheckBox3.isSelected() && !jCheckBox2.isSelected()){
            logkodolas();
            log();
            logkodolas();
        }*/
        jLabel1.setForeground(Color.black);
        jLabel1.setText("          Válassza ki a fájlt");
//        jLabel2.setText("Jelszó %");
        jCheckBox2.setSelected(false);
        jButton1.setText("Kódolás");
        jComboBox4.setEnabled(true);
        jComboBox3.setEnabled(true);
        jComboBox2.setEnabled(true);
        jComboBox1.setEnabled(true);
         jFileChooser1.rescanCurrentDirectory();
         jComboBox1.setSelectedIndex(0);
         jComboBox2.setSelectedIndex(0);
         jComboBox3.setSelectedIndex(0);
         jComboBox4.setSelectedIndex(0);
         kursor(0);
       
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jPasswordField1KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jPasswordField1KeyPressed
         // TODO add your handling code here:a jelszo hossz ellenorzese
         
        
      
    }//GEN-LAST:event_jPasswordField1KeyPressed

    private void jPasswordField2FocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jPasswordField2FocusLost
        // TODO add your handling code here:két beírt jelszó ellenőrzése
        if(roviduzenet)return;
        if(!kulcsolt){
            if(jPasswordField2.getText() == null ? jPasswordField1.getText() != null : !jPasswordField2.getText().equals(jPasswordField1.getText())){
                jTextArea1.setText("Hibás Jelszavak");
                jPasswordField1.setText("");
                jPasswordField2.setText("");
                //%%jProgressBar1.setValue(1);
                 jPasswordField1.setBackground(Color.red);
                  
                jPasswordField2.setBackground(Color.white);
                return;
            }
            else {
                if(jPasswordField1.getText().length()<3 || jPasswordField2.getText().length()<3)return;
                    
                jTextArea1.setText("\nJelszavak egyeznek...");
            }
            if(jComboBox6.getSelectedIndex()==4){
                
                jTextArea1.setText("\nHúzza a kódolandó állományok könyvtárát a lila mezőre");
                 pw=jPasswordField1.getText();
                 jta2=jTextArea2.getText();
                return;
            }
            pw=jPasswordField1.getText();
            jCheckBox2.setEnabled(false);
            //jTextArea1.setText("");
             jPasswordField1.setBackground(Color.white);
              jPasswordField2.setBackground(Color.white);
              jButton1.setFocusable(true);
        }
        //kodoltneve=String.valueOf(rand)+"."+pw.length()+"."+pw.substring(1,3)+"."+pw.substring(pw.length()-1,pw.length());*/
        if(jCheckBox2.isSelected());
        else{
            kodoltneve=jFileChooser1.getSelectedFile().getName()+"_+_"+pw.length()+"_"+pw.substring(1,3)+"_"+pw.substring(pw.length()-1,pw.length());
            kodoltneve=kodoltneve+"_"+String.valueOf(jComboBox1.getSelectedIndex())+"_"
                    +String.valueOf(jComboBox2.getSelectedIndex())+"_"+String.valueOf(jComboBox3.getSelectedIndex())
                    +"_"+jComboBox4.getSelectedItem()+"?";
            //jTextArea1.append("Fájl eredeti neve: "+jFileChooser1.getSelectedFile().getName()+"\n");
            //jTextArea1.append("Fájl eredeti helye: "+jFileChooser1.getSelectedFile().getPath()+"\n");
            //jTextArea1.append("Fájl kodneve: "+kodoltneve+"\n");
        }
        try {
            jTextArea1.append("\nFájl méret: "+String.valueOf((kodolando.available())/1024/1024)+" Mbájt ");
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        Calendar cal = Calendar.getInstance();
        jTextArea1.append("\nKezdési idő: "+cal.getTime());
        jTextArea1.append("\nKódolás a Kódolás indítása gombbal megkezdhető, rezettel a kezdés visszavonható\n"
                + "Ha megkezdte a folyamatot nem szakítható meg. Ha vége a piros mező zöldre vált.\n\n"
                + "Most már nem állíthatja a PIN-t. De ha kódol, írhat a fájlhoz megjegyzést, üzenetet.\n"
                + "Ha elfelejtette beállítani a PIN-t, nyomja meg a mégse gombot és kezdje előről a műveletet.");
                kursor(3);
        jPasswordField1.setText("");
        jPasswordField2.setText("");
       // jProgressBar1.setValue(0);
        jTextArea1.setBackground(Color.RED);
        jTextArea1.setForeground(Color.black);
        jComboBox4.setEnabled(false);
        jComboBox3.setEnabled(false);
        jComboBox2.setEnabled(false);
        jComboBox1.setEnabled(false);
        //jButton1.Showing();
    }//GEN-LAST:event_jPasswordField2FocusLost

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        // TODO add your handling code here:
        //if((logszamlalo%2)>0)logkodolas();
        kontenerlezar();
        if(Inputnyitott)streamclos1();
        if(Outputnyitott)streamclos2();
        
        
    }//GEN-LAST:event_formWindowClosed

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        // TODO add your handling code here:
        //jButton1.hide();
                //timestampellenorzes();
         regiek=new long[sorbanalhatnak];    
        //programnév ellenörzés
         try {
                    try ( 
                            DataInputStream neve = new DataInputStream(new FileInputStream("Kriptova.jar"))) {
                        
                    }
        } catch (FileNotFoundException ex) {
            jTextArea1.setText("");
            jTextArea1.setBackground(Color.white);
            jTextArea1.setForeground(Color.red);
            jTextArea1.append("\nA program át lett nevezve.  Állítsa le és nevezze vissza Kriptova.jar névre, hogy használni tudja.");
            jButton7.setEnabled(false);
            jCheckBox8.setSelected(false);
            //System.exit(0);
            
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            return;
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //-----------------------------
        try {
                    try ( //munkakonyvtar beallitas
                            DataOutputStream hol = new DataOutputStream(new FileOutputStream("ez_mar_nincs_itt"))) {
                        hol.writeBoolean(true);
                    }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
                File dir= new File ("ez_mar_nincs_itt");
                
                jFileChooser1.setCurrentDirectory(dir);
                dir.delete();
                 jButton10.setEnabled(false);
                 jButton12.setEnabled(false);
                 jButton8.setEnabled(false);
                 jButton9.setEnabled(false);
                 
                 jCheckBox5.setSelected(false);
                 logkeynyit();
                 jFileChooser1.rescanCurrentDirectory();
                 
                  
        
       // szal2 = new Thread();
        // szal1 = new Thread();
        
        
          
    }//GEN-LAST:event_formWindowOpened

    
    private void jPasswordField1FocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jPasswordField1FocusLost
        // TODO add your handling code here:
        if(jPasswordField1.getText().length()<4)return;
        jPasswordField2.setEditable(true);
         jPasswordField1.setBackground(Color.white);
          jPasswordField2.setBackground(Color.red);
    }//GEN-LAST:event_jPasswordField1FocusLost

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
            DataOutputStream labnyom = null;
            jTextArea1.setText("");
        try {
            // TODO add your handling code here:
            if(jComboBox6.getSelectedIndex()==0);
            else  if(jComboBox6.getSelectedIndex()==1){
                if(!torol){
                jTextArea1.append("\nKriptova takarító. A szabad hely törlése az adott meghajtón.");
                jTextArea1.append("\nBiztos benne, hogy elkezdi a műveletet? A meghajtó méretétől függően sokáig tarthat\n"
                        + "megszakítani nem lehet az elindított folyamatot. Töröl vagy Rezet-Mégsem gombbokkal választhat\n"
                        + "Többszörí felülíráshoz válassza ki a pin 1-ből a felülírások számát\n"
                        + "Alapérteelmezésben 1-szer írja felül a szabad helyet");
                         
                        torol=true;
                        jTextArea1.setBackground(Color.red);
                        kursor(3);
                        return;
                }
                kezd();
                int ciklus;
                if(jComboBox1.getSelectedIndex()==0)ciklus=1;
                else ciklus=jComboBox1.getSelectedIndex();
                for(int a=0;a<ciklus;a++){
                jTextArea1.setBackground(Color.black);
                File dir,dur;
                dir=new File("kriptova_takarito");
                
                jTextArea1.append("\nKönyvtár: "+jFileChooser1.getCurrentDirectory().getAbsolutePath());
               
                byte [] kklny; 
                kklny =new byte[(1024*1024)];
                for(int i=0;i<1024*1024;i++)kklny[i]=(byte) generator();
                dir.mkdir();
                dur=jFileChooser1.getCurrentDirectory();
                jFileChooser1.setCurrentDirectory(dir);
                 long freespace=dur.getFreeSpace();
                jTextArea1.append("\nSzabadhely: "+String.valueOf(freespace/1024/1024/1024)+" GB");
                
                long vissza=dir.getFreeSpace();
                while(dir.getFreeSpace()>2048){
                    
                    labnyom=new DataOutputStream(new FileOutputStream("kriptova_takarito\\"+String.valueOf(vissza--)));
                    try {
                        labnyom.write(kklny);
                        labnyom.writeUTF("Kriptova_takarito_algoritmus_");
                        } catch (IOException ex) {
                        try {
                            labnyom.close();
                        } catch (IOException ex1) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                            break;
                        }
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            break;
                        }
                    try {
                        labnyom.close();
                    } catch (IOException ex) {
                        jTextArea1.append("\nFájl zárási hiba");
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    
                    //break;
                    
                }
                            jTextArea1.append("\nÍrás végén a ");
                            freespace=dir.getFreeSpace();
                            jTextArea1.append("szabadhely: "+String.valueOf(freespace/1024)+" Kbyte");
                            //listázni és törölni mindent a könyvtárból
                            String [] torolni;
                            torolni=dir.list();
                            int fajl=torolni.length;
                            for(int i=0;i<fajl;i++){
                                labnyom=new DataOutputStream(new FileOutputStream("kriptova_takarito\\"+torolni[i]));
                            try {
                                labnyom.writeBoolean(false);
                            } catch (IOException ex) {
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                                try {
                                    labnyom.close();
                                    dir=new File("kriptova_takarito\\"+torolni[i]);
                                    //jTextArea1.append(dir.getAbsoluteFile().getName());
                                    dir.delete();
                                } catch (IOException ex1) {
                                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                                }
                            
                            }
                dir.delete();
                jFileChooser1.setCurrentDirectory(dur);
                dir = new File("kriptova_takarito");
                dir.delete();
                
               
                
                }
                kursor(0);
                jComboBox6.setSelectedIndex(0);
                vegez();
                jButton2.setText("Biztonsági törlés");
                return;
            
            }
            else  if(jComboBox6.getSelectedIndex()==2){
                if(!torol){
                    jTextArea1.append("\nFájlok törlése a kiválasztott könyvtártól lefelé!\nNyomja meg a Biztonsági"
                            + "törlés gombot, vagy ha nem kivánja megkezdeni a műveletet a Rezet-Mégsem gombot");
                     torol=true;
                    jTextArea1.setBackground(Color.red);
                    jButton2.setText("Biztonsági törlés");
                    kursor(3);
                    return;
                    }else{
                //a műveleti ág
                    kezd();
                    gyorstorles();
                    jFileChooser1.rescanCurrentDirectory();
                    jTextArea1.setBackground(Color.black);
                    torol=false;
                    kursor(0);
                    vegez();
                
                }
                jButton2.setText("Biztonsági törlés");
                jComboBox6.setSelectedIndex(0);
                kursor(0);
                return;
            }
            else  if(jComboBox6.getSelectedIndex()==3){
                if(!torol){
                jTextArea1.append("\nFájlok gyorskódolása az adott könyvtárban.");
                jTextArea1.append("\nBiztos benne, hogy elkezdi a műveletet? Akkor jegyezze meg az indítási pint!\n"
                        + "A dekódolás ugyanígy történik. Megszakítani nem lehet az elindított folyamatot. \nGyorskódolás vagy a Rezet-Mégsem gombbokkal választhat");
                torol=true;
                jTextArea1.setBackground(Color.red);
                jButton2.setText("  Gyorskódolás   ");
                kursor(3);
                return;
                }else{
                //a műveleti ág
                    kezd();
                    list1.removeAll();
                    gyorskodolas();
                    if(jCheckBox5.isSelected()){
                        doboz.seek(fejlecpointer);
                        kontfejlecbeolvas();
                    }
                    
                    jTextArea1.setBackground(Color.black);
                    torol=false;
                    vegez();
                }
                
                jButton2.setText("Biztonsági törlés");
                jComboBox6.setSelectedIndex(0);
                kursor(0);
                return;
            
            }
            
            if(jFileChooser1.getSelectedFile()==null){jTextArea1.append("\nFájl: nincsen fájl kiválasztva"); jTextArea1.setBackground(Color.yellow);return;}
            else if(!torol){
                jTextArea1.append("\n\nBiztos törli a kiválasztott fájlt? Töröl vagy Reset");
                jTextArea1.append("\n"+jFileChooser1.getSelectedFile().getName());
                 jTextArea1.setBackground(Color.RED);
                 jTextArea1.setForeground(Color.black);
                 jLabel1.setForeground(Color.black);
                 jLabel1.setText("          Válassza ki a fájlt");
                torol=true;
                if(jFileChooser1.getSelectedFile().getAbsolutePath() == null ? kulcsnev == null : jFileChooser1.getSelectedFile().getAbsolutePath().equals(kulcsnev)){
                     jTextArea1.append("\n\nA mesterkulcsot választotta törlésre. Biztos benne?");
                
                }
                return;
            }
            ftorol();
            
            jFileChooser1.rescanCurrentDirectory();
            torol=false;
            
        } catch (FileNotFoundException ex) {
            jTextArea1.append("\n IO hiba");
                try {
                    labnyom.close();
                    kursor(0);
                } catch (IOException ex1) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                }
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        jTextArea1.setBackground(Color.black);
        jTextArea1.setForeground(Color.yellow);
        kursor(0);
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jCheckBox4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox4ActionPerformed
        // TODO add your handling code here:
        if(jCheckBox4.isSelected()){
            jComboBox1.setSelectedIndex(0);
            jComboBox2.setSelectedIndex(0);
            jComboBox3.setSelectedIndex(0);
            jComboBox4.setSelectedIndex(0);
            jTextArea1.setText("");
            jTextArea1.append(" \n\n Állíthat be a 4 jegyü 'pint' jelszó helyett, majd válassza ki a kulcsfájlt\n"
                    + "A pin megadása nem kötelező. Dekódoláskor ugyanezt a fájlt kell használnia kulcsnak\n"
                    + "Semmiképpen ne változtasson a tartalmán, mert akkor a dekódolás sikertelen lesz.");
            jCheckBox2.setEnabled(false);
        }else jCheckBox2.setEnabled(true);
    }//GEN-LAST:event_jCheckBox4ActionPerformed

    private void jButton3MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton3MouseClicked
     // TODO add your handling code here:// Resetgomb változók nullázása
        
        
        if(jComboBox1.getSelectedIndex()==7 && jComboBox2.getSelectedIndex()==7 && jComboBox3.getSelectedIndex()==7 && jComboBox4.getSelectedIndex()==7){
            try {
                byte [] ujkulcs;
                ujkulcs = new byte[250];
                String crc=jPasswordField3.getText();
                int crchossz=crc.length();
                long crckod=0;
                //DataOutputStream logfile = null;
                long tol;
                Calendar cal = Calendar.getInstance();
                tol = cal.getTimeInMillis();
                
                
                for(int a=0;a<crchossz;a++)crckod=(long)crckod+crc.charAt(a); //masterpass crc
                if(crckod==0){ jTextArea1.append("\nAdjon meg egy mesterjelszót, ami a mesterkulcs jelszava lesz."
                        + "\nés jól jegyezze meg(legalább 8 karakter)");return;}
                else if(crchossz<8){ jTextArea1.append("\nA mesterjelszó, hossza legyen legalább 8 karakter");return;}
                for(int i=0;i<250;i++){
                    
                    ujkulcs[i]=generator();
                }
                try {
                    kodolt = new DataOutputStream(new FileOutputStream(String.valueOf(ujkulcs.hashCode())+"kriptova.key"));
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                
                try {
                    kodolt.writeLong(crckod);
                    kodolt.write(ujkulcs);
                    kodolt.writeLong(Arrays.hashCode(ujkulcs));
                } catch (IOException ex) {
                    jTextArea1.append("ujkulcs írás hiba");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
               
               /* try {
                    logfile = new DataOutputStream(new FileOutputStream(String.valueOf(tol)+".kriptlog"));
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }logfile.close();
                kodolt.writeUTF(String.valueOf(tol)+".kriptlog");*/
                kodolt.close();
                
                System.exit(0);
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        //if((logszamlalo%2)>0)logkodolas();
        torol=false;
        jTextArea2.setText("");
        listaboltorol=false;
        jCheckBox2.setEnabled(true);
        jButton1.setText("Kódolás");
        pinvaltas=false;
         hozzaad=false;
         kontenernyitas=false;
         jPasswordField3.setText("");
         jPasswordField3.setBackground(Color.green);
        jCheckBox2.setSelected(false);
        //jCheckBox3.setSelected(true);
        jCheckBox4.setSelected(false);
        jCheckBox1.setSelected(false);
        jTextArea1.setText("");
        jLabel1.setForeground(Color.black);
        jLabel1.setText("          Válassza ki a fájlt");
        //jLabel2.setText("Jelszó % ");
        jComboBox1.setSelectedIndex(0);
        jComboBox2.setSelectedIndex(0);
        jComboBox3.setSelectedIndex(0);
        jComboBox4.setSelectedIndex(0);
        //jProgressBar1.setValue(1);
        jTextArea1.setBackground(Color.black);
        jTextArea1.setForeground(Color.yellow);
        pw="";
        kodoltneve="";
        kodnev="";
         jFileChooser1.rescanCurrentDirectory();
        if(Inputnyitott)streamclos1();
        if(Outputnyitott)streamclos2();
        
        // TODO add your handling code here:
    }//GEN-LAST:event_jButton3MouseClicked

    private void jCheckBox5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox5ActionPerformed
        // TODO add your handling code here:
         kontener = jCheckBox5.isSelected();
         kontenergeneralas=false;
          if(jCheckBox5.isSelected()){
                list1.removeAll();
             try {
                 if(!"false".equals(kontenernev))doboz.seek(fejlecpointer);
             } catch (IOException ex) {
                 jTextArea1.append("\n\nNyissa meg a konténerfájlt");
                 Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
             }
             if(!"false".equals(kontenernev)){
                    jComboBox1.setSelectedIndex(kpin1);
                    jComboBox2.setSelectedIndex(kpin2);
                    jComboBox3.setSelectedIndex(kpin3);
                    jComboBox4.setSelectedIndex(kpin4);
                    jComboBox1.setEnabled(false);
                    jComboBox2.setEnabled(false);
                    jComboBox3.setEnabled(false);
                    jComboBox4.setEnabled(false);
                    //kontfejlecbeolvas();
                     jComboBox9.setSelectedIndex(0);
             }
                
                jTextArea1.append("\n\nKonténer funkciók bekapcsolva");
                jTextArea2.setText("");
                jLabel1.setText("          Válassza ki a fájlt");
                jLabel1.setForeground(Color.black);
                if(Inputnyitott)streamclos1();
                if(Outputnyitott)streamclos2();
                //jCheckBox6.setSelected(false);
                //jCheckBox6.setEnabled(false);
               
          }
          else{ 
              jTextArea1.append("\nKonténer funkciók kikapcsolva");
              jTextArea2.setText("Itt rövid, maximum 450 karakter megjegyzést fűzhet, kódolás előtt a fájlhoz.\n" 
                        +"Amit, a kodoláskori beállításokkal indítva, a dekódolás bekapcsolásával kiolvashat.");
              //jCheckBox6.setEnabled(true);
              jComboBox1.setEnabled(true);
                    jComboBox2.setEnabled(true);
                    jComboBox3.setEnabled(true);
                    jComboBox4.setEnabled(true);
                    jComboBox1.setSelectedIndex(0);
                    jComboBox2.setSelectedIndex(0);
                    jComboBox3.setSelectedIndex(0);
                    jComboBox4.setSelectedIndex(0);
          }
           jPasswordField1.setBackground(Color.white);
           jPasswordField2.setBackground(Color.white);
    }//GEN-LAST:event_jCheckBox5ActionPerformed

    private void jCheckBox5MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckBox5MouseClicked
        // TODO add your handling code here:
       kontener = jCheckBox5.isSelected();
    }//GEN-LAST:event_jCheckBox5MouseClicked

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        // TODO add your handling code here: Konténerfájl megnyitása
        jTextArea1.setText("");
        String net;
        net=jTextArea2.getText();
        if(net.length()>10){
        
            int van=net.indexOf("net:");
            if(van<0);
            else{
                
                net=net.substring(4,net.length());
                jTextArea1.append(net);
                //url megnyitása olvasásra ha lehet írásra
                
                return;
                
            }
        }
        
        if(kontenergeneralas)kontenergeneralas=false;
        if(jCheckBox5.isSelected()){
            kontenernyitas=true;
            if(kny>0){//ha feltehetőleg van nyitott konténer
                jTextArea1.append("\n\nZárja be a nyitott konténert");
                return;
            }
            jTextArea1.setBackground(Color.yellow);
            jTextArea1.setForeground(Color.black);
             jTextArea1.append("\n\nHa tartozik a konténerhez pin kód akkor azt most még állítsa be");
            jTextArea1.append("\nVálassza ki a könyvtárstruktúrából a konténerfájlt\ndupla kattintással vagy kijelölés, enter gomb\n");
                  // jTextArea1.append("\nVagy írja be a felső mezőbe, a szöveg törlése után, hogy net:http:\\\\www....\\.....stb\n"
                 //   + "Formátumba a címet és nyomja meg újra a gombot");
        }
        else {jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.CYAN);jTextArea1.setForeground(Color.black);}
    }//GEN-LAST:event_jButton4ActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        // TODO add your handling code here: Konténer lezár
        kny=0;
        jPasswordField3.setText("");
        jPasswordField3.setBackground(Color.green);
        kontenerlezar();
         
    }//GEN-LAST:event_jButton5ActionPerformed

    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton6ActionPerformed
        // TODO add your handling code here:konténer létrehoz
         if(jCheckBox5.isSelected()){
             jTextArea1.setBackground(Color.yellow);   
             jTextArea1.setForeground(Color.black);
             jTextArea1.append("\n\nAdja meg a konténer mesterjelszavát, majd a beír gombbal indíthatja \na konténerfájl generálását: jelszó minimum 8 karakter");
             kontenergeneralas=true;
        }
        else {jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.CYAN);jTextArea1.setForeground(Color.black);}
    }//GEN-LAST:event_jButton6ActionPerformed

    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton7ActionPerformed
        
       button7();
    }//GEN-LAST:event_jButton7ActionPerformed

    private void jButton9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton9ActionPerformed
        // TODO add your handling code here:konténer tömörítés
        /* if(kfbe){
             jTextArea1.append("\n\nA tömörítési műveletet csak kulcsforgatási funkció NÉLKÜL indított módban lehet elvégezni");
             return;
         }*/
        kursor(3);
         if(jCheckBox5.isSelected()){
             if(tomorithet){ 
                 jCheckBox7.setSelected(true);
                 tomorites(); tomorithet=false;kursor(0);}
             else{
                  jTextArea1.setForeground(Color.red);
                  
                 jTextArea1.append("\n\nBiztos benne? A tömörítés után ez a konténer nem lesz többé megnyitható!\nÉs csak a listában megtalálható állományok kerülnek az létrejövő új konténer állományba"
                         + "\nHa nem biztos benne nyomja meg a mégsem gombot."); 
                 tomorithet=true;
             }
        }
        else {jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.ORANGE);jTextArea1.setForeground(Color.black);kursor(0);}
    }//GEN-LAST:event_jButton9ActionPerformed

    private void jButton10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton10ActionPerformed
        // TODO add your handling code here: konténerből kihalászás
        int indexor = jComboBox9.getSelectedIndex();
        kursor(3);
         if(jCheckBox5.isSelected()){//mindet kibontani
             if(jCheckBox3.isSelected()){
                 jComboBox9.setSelectedIndex(0);
                 list1.select(1);
                 for(int i=0; i<list1.getItemCount();i++){
                     list1.select(i);
                        
                        for(int a=0;a<kontfajlnev.length-1;a++){

                           if(list1.getSelectedItem() == null ? kontfajlnev[a] == null : list1.getSelectedItem().equals(kontfajlnev[a])){
                               
                               
                               
                               if(kontflag[a])szamol=a;
                               
                               

                               kontenerbolkibont();
                              
                               

                           }
                       } 
                 
                 
                 }
                 jComboBox9.setSelectedIndex(indexor);
                 
                 jTextArea1.setBackground(Color.black);
                 jTextArea1.setForeground(Color.yellow); 
                 jTextArea1.append("\n\nA konténerből dekoldólt: "+String.valueOf(list1.getItemCount())+" db állomány.");
                 jCheckBox3.setSelected(false);
                 kursor(0);
                 if(jCheckBox11.isSelected())System.exit(0);
                 return;
             
             }
             
             if(list1.getSelectedIndex()<0){
                 jTextArea1.append("\nNincsen kikódolásra kijelölve tétel.");
                 listaboltorol=false;
                 kursor(0);
                 return;
             }
             else{//egyet kibontani
                 String kibontani=list1.getSelectedItem();
                 //jComboBox9.setSelectedIndex(0);
                 long egyforma=1;
                 long or=0;
                for(int i=0;i<kontfajlnev.length-1;i++){
                 
                    if(kibontani == null ? kontfajlnev[i] == null : kibontani.equals(kontfajlnev[i])){
                            if(kontflag[i])szamol=i;
                            egyforma=konpoint[i];
                               

                               if(egyforma!=or)kontenerbolkibont();
                               or=egyforma;
                            
                            jTextArea1.setBackground(Color.black);
                            jTextArea1.setForeground(Color.yellow);
                            
                    }
                } 
                jComboBox9.setSelectedIndex(indexor);
                kursor(0);
                if(jCheckBox11.isSelected())System.exit(0);
                 return;
             }
             
        
        }
        else {jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.ORANGE);jTextArea1.setForeground(Color.black);kursor(0);}
    }//GEN-LAST:event_jButton10ActionPerformed

    private void jButton8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton8ActionPerformed
        // TODO add your handling code here: Konténerből minden tétel törlése
        int a=jComboBox9.getSelectedIndex();
        int b=list1.getSelectedIndex();
         if(jCheckBox5.isSelected()){
             if(listaboltorol){
                if(jCheckBox3.isSelected()){
                    
                        for(int i=0;i<kontfajlnev.length-1;i++){
                            list1.select(0);
                                
                                szamol=i;
                                torlesrejelol();
                                 
                                
                        
                       
                        
                      
                     
                    
                    }
                    jTextArea1.append("\nA tételek törölve lettek.");
                    listaboltorol=false;
                    jCheckBox3.setSelected(false);
                    
                }
                else { 
                    
                    for(int i=0;i<kontfajlnev.length-1;i++){

                        if(list1.getSelectedItem() == null ? kontfajlnev[i] == null : list1.getSelectedItem().equals(kontfajlnev[i])){
                                if(kontflag[i])szamol=i;
                        }
                    }  
                     jTextArea1.setBackground(Color.yellow);
                     jTextArea1.setForeground(Color.black);
                    torlesrejelol(); 
                     jTextArea1.setBackground(Color.black);
                     jTextArea1.setForeground(Color.yellow);
                    jTextArea1.append("\nA kijelölt tétel törölve lett.");
                    listaboltorol=false;
                    jComboBox9.setSelectedIndex(a);
                    if(b>0)list1.select(b-1);
                    listaeleme();
                    return;
                    }
                }
             
            
             if(list1.getSelectedIndex()<0){
                 jTextArea1.append("\nNincsen törlésre kijelölve tétel.");
                 listaboltorol=false;
                 return;
             }
             else{
                 if(jCheckBox3.isSelected()){
                     jTextArea1.setText("");
                     jTextArea1.append("\nMinden törlése bejelölve.\n"
                             + "\nHa nem nyomja meg a mégsem gombot");
                  listaboltorol=true;
                 }
                 else {
                     jTextArea1.append("\nBiztos, hogy törli a kijelölt tételt?\n Ha igen nyomja meg a gombot ismét\nHa nem nyomja meg a mégsem gombot");
                  listaboltorol=true;
                 return;
                 }
             }
        
        }
        else {jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.ORANGE);jTextArea1.setForeground(Color.black);}
    }//GEN-LAST:event_jButton8ActionPerformed

    private void jButton12ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton12ActionPerformed
        // TODO add your handling code here: Fájl hozzáadása a konténerhez
        //sorban állókat ellenörizni
        
        if(sorbanall());
        else{
            return;
        }
        
         if(jCheckBox5.isSelected()){
             jTextArea1.append("\n\nKattintson duplán a hozzáadandó fájlon. Ha egész mappa tartalmát \n"
                     + "akarja a konténerhez adni akkor a mappát húzza rá a lila mezőre\n"
                     + "Várja meg, amíg a fájl megjelenik a listában, és az üzenetmezőben\n"
                     + "a művelet eredményének a megerősítése. Addig nem tud új műveletbe kezdeni.\n"
                     + "Mégsem gombbal elhalaszthatja a műveletet, de nem szakíthatja meg, ha megkezdte.");
             for(int a=1;a<kontfilenevhossz;a++)filenevkiolvaso[a]=' ';
             hozzaad=true;
             kontenernyitas=true;
        }
        else {jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.ORANGE);jTextArea1.setForeground(Color.black);kursor(0);}
    }//GEN-LAST:event_jButton12ActionPerformed

    private void jButton11ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton11ActionPerformed
        // TODO add your handling code here:
        helyreallit=0;
        listaboltorol=false;
        tomorithet=false;
         hozzaad=false;
         kontenergeneralas=false;
         
         if(pinvaltas){
             jButton10.setEnabled(true);
                 
                 jButton12.setEnabled(true);
                 jButton8.setEnabled(true);
                 jButton9.setEnabled(true);
                // jButton15.setEnabled(true);
                 pinvaltas=false;
         }
         if(kontenernyitas){
                kontenernyitas=false;}
          jPasswordField3.setText("");
         jPasswordField3.setBackground(Color.green);
         jTextArea1.append("\n Műveleti indítás visszavonva");
         jTextArea1.setBackground(Color.black);
         jTextArea1.setForeground(Color.yellow);
         kursor(0);
    }//GEN-LAST:event_jButton11ActionPerformed

    private void jButton7KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jButton7KeyPressed
        // TODO add your handling code here:
        kursor(3);
        button7();
        kursor(0);
    }//GEN-LAST:event_jButton7KeyPressed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        kursor(0);
        jPasswordField1.setBackground(Color.white);
         jPasswordField1.setText("");
         jPasswordField2.setText("");
              jPasswordField2.setBackground(Color.white);
              jTextArea2.setEditable(true);
              jFileChooser1.setSelectedFile(null);
              jLabel3.setText("Fájl:");
              jComboBox7.setEnabled(false);
              jCheckBox9.setSelected(false);
              jCheckBox4.setEnabled(true);
        jComboBox4.setEnabled(true);
        jComboBox3.setEnabled(true);
        jComboBox2.setEnabled(true);
        jComboBox1.setEnabled(true);
         jButton2.setText("Biztonsági törlés");
         jComboBox6.setSelectedIndex(0);
    }//GEN-LAST:event_jButton3ActionPerformed

    private void list1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_list1MouseClicked
        // TODO add your handling code here://olvassa ki a méretet
        //if(list1.isFocusable()){
            listaeleme();
      //  }
    }//GEN-LAST:event_list1MouseClicked

    private void jButton13ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton13ActionPerformed
        // TODO add your handling code here:véletlen számokkal feltötött kulcsállomány generálása
         kezd();
        //long meret;
        byte [] kulcsmeret;
        int index = jComboBox5.getSelectedIndex();
        //if(index==0)meret=1024*1024;
        //else meret=index*10*1024*1024*1024;
        DataOutputStream randomkulcs = null;
        String kulcsneve=String.valueOf(kezdet)+".rndkey";
        try {
            randomkulcs=new DataOutputStream(new FileOutputStream(kulcsneve));
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        kulcsmeret=new byte[100000000];
        for(int a=0;a<index+1;a++){
            for(int i=0;i<kulcsmeret.length-1;i++)kulcsmeret[i]=generator();
                try {
                    randomkulcs.write(kulcsmeret);
                } catch (IOException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                
            }
        try {
                randomkulcs.close();
            } catch (IOException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
         jTextArea1.append("\nA generált kulcs neve: "+kulcsneve);
        vegez();
        
    }//GEN-LAST:event_jButton13ActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        // TODO add your handling code here:
        if(jCheckBox8.isSelected()){
                try {
                           try ( //önmegsemmisítés

                                   DataOutputStream hol = new DataOutputStream(new FileOutputStream("kriptova.jar"))) {
                               hol.writeBoolean(true);
                               for(int i=0;i<3000;i++)hol.writeBytes("Önmegsemmisítés lefutott");
                           }
               } catch (FileNotFoundException ex) {
                   Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
               } catch (IOException ex) {
                   Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
               }
        }       
         ;
    }//GEN-LAST:event_formWindowClosing

    private void jButton14ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton14ActionPerformed
        // TODO add your handling code here:Munkakönyvtárba ugrik
       munkakonyvtar();
                
    }//GEN-LAST:event_jButton14ActionPerformed

    private void jButton15ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton15ActionPerformed
        // TODO add your handling code here: a torolt tételek visszaállítása
        jTextArea1.append("\n\nA törlésre jelölt tételek újboli elérhetővé tétele.\nTömörítés után a törölt tételek nem állythatóak vissza.");
        visszaallit();
        
        
    }//GEN-LAST:event_jButton15ActionPerformed

    private void jCheckBox6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox6ActionPerformed
        // TODO add your handling code here:
         if(jCheckBox6.isSelected())jTextArea1.append("\n\nKulcsforgatás bekapcsolva - lassabb de maximális biztonságot ad.");
        else jTextArea1.append("\nKulcsforgatás kikapcsolva");
    }//GEN-LAST:event_jCheckBox6ActionPerformed

    private void jCheckBox8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox8ActionPerformed
        // TODO add your handling code here:
         if(jCheckBox8.isSelected())jTextArea1.append("\n\nA Kriptova program használhatatlanná tétele leállításkor, bekapcsolva");
        else jTextArea1.append("\nA Kriptova program használhatatlanná tétele leállításkor, kikapcsolva");
    }//GEN-LAST:event_jCheckBox8ActionPerformed

    private void jCheckBox7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox7ActionPerformed
        // TODO add your handling code here:
        if(jCheckBox7.isSelected())jTextArea1.append("\n\nKétkulcsos konténer titkosítás bekapcsolva");
        else jTextArea1.append("\nKétkulcsos konténer titkosítás kikapcsolva");
    }//GEN-LAST:event_jCheckBox7ActionPerformed

    private void jComboBox4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox4ActionPerformed
        // TODO add your handling code here:
        if(jComboBox4.getSelectedIndex()==7 && jComboBox2.getSelectedIndex()==7 &&jComboBox3.getSelectedIndex()==7 &&jComboBox1.getSelectedIndex()==7)
            jButton3.setEnabled(true);
        
    }//GEN-LAST:event_jComboBox4ActionPerformed

    private void jComboBox3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox3ActionPerformed
        // TODO add your handling code here:
         if(jComboBox4.getSelectedIndex()==7 && jComboBox2.getSelectedIndex()==7 &&jComboBox3.getSelectedIndex()==7 &&jComboBox1.getSelectedIndex()==7)
            jButton3.setEnabled(true);
    }//GEN-LAST:event_jComboBox3ActionPerformed

    private void jComboBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox2ActionPerformed
        // TODO add your handling code here:
         if(jComboBox4.getSelectedIndex()==7 && jComboBox2.getSelectedIndex()==7 &&jComboBox3.getSelectedIndex()==7 &&jComboBox1.getSelectedIndex()==7)
            jButton3.setEnabled(true);
    }//GEN-LAST:event_jComboBox2ActionPerformed

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        // TODO add your handling code here:
         if(jComboBox4.getSelectedIndex()==7 && jComboBox2.getSelectedIndex()==7 &&jComboBox3.getSelectedIndex()==7 &&jComboBox1.getSelectedIndex()==7)
            jButton3.setEnabled(true);
    }//GEN-LAST:event_jComboBox1ActionPerformed

    private void jPasswordField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPasswordField1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jPasswordField1ActionPerformed

    private void jTextArea2KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextArea2KeyPressed
        // TODO add your handling code here:
        if(roviduzenet){
            jLabel1.setText("       Beírt karakter száma:"+String.valueOf(jTextArea2.getText().length())); 
        return;
        }
        jLabel1.setText("       Karakter hely szabad:"+String.valueOf(450-jTextArea2.getText().length()));
        if(450-jTextArea2.getText().length()<1){
            jLabel1.setText("       Elfogyott a szabad hely");
            jTextArea2.setEditable(false);
        }
    }//GEN-LAST:event_jTextArea2KeyPressed

    private void jPasswordField1FocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jPasswordField1FocusGained
        // TODO add your handling code here:
        jPasswordField1.setBackground(Color.red);
    }//GEN-LAST:event_jPasswordField1FocusGained

    private void jComboBox6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox6ActionPerformed
        // TODO add your handling code here:
        if(jComboBox6.getSelectedIndex()==3)jButton2.setText("  Gyorskódolás   ");
        else jButton2.setText("Biztonsági törlés");
        switch (jComboBox6.getSelectedIndex()) {
            case 0:
                
                jTextArea1.append("\n");
                jCheckBox2.setEnabled(true);
                break;
            case 1:
                jTextArea1.setText("");
                jTextArea1.append("\nA meghajtón lévő szabad hely felülírása");
                jCheckBox2.setEnabled(true);
                break;
            case 2:
                jTextArea1.setText("");
                jTextArea1.append("\nAz aktuális könyvtárban lévő fájlok almappák tartalmának felülírása gyorstörlése");
                jCheckBox2.setEnabled(true);
                break;
            case 3:
                jTextArea1.setText("");
                jTextArea1.append("\nAz aktuális mappában lévő állományok gyorskódolása az aktuális Hkód szerint");
                jCheckBox2.setEnabled(true);
                break;
            case 4:
                jTextArea1.setText("");
                 if(jCheckBox2.isSelected()){
                     jTextArea1.append("\nA tömeges dekódolás funkció nem elérhető.\n"
                        + "Kérem válassza ki a dekódolandó állományt normál módban.");
                 jComboBox6.setSelectedIndex(0);
                 return;
                 }
                 if(jCheckBox5.isSelected()){
                     jTextArea1.append("\nA Konténer használat be van jelölve!\n\n"
                             + "Ha így hagyja a kódolt állományok a konténerbe kerülnek\n"
                             + "Ha nem akarja kapcsolja ki a konténer használatot.");
                 }
                jTextArea2.setText("Megjegyzes a csoportos titkositashoz : ");
                jTextArea1.append("\nAz aktuális mappában és almappákban lévő állományok teljes kódolása.\n"
                        + "Irja be a megjegyzést ha szükséges, állítsa be a pint és írja be a jelszót\n"
                        + "Majd húzza a kezdő könyvtárat a lila mezőre");
                jPasswordField1.setEditable(true);
               
                jCheckBox2.setSelected(false);
                jCheckBox2.setEnabled(false);
                break;
            default:
                break;
        }
    }//GEN-LAST:event_jComboBox6ActionPerformed

    private void jCheckBox9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox9ActionPerformed
        // TODO add your handling code here://vezérlés
        if(jCheckBox9.isSelected()){
            jComboBox7.setEnabled(true);
            jCheckBox4.setEnabled(false);
            roviduzenet=true;
            jTextArea1.setText("");
            jPasswordField1.setEditable(true);
            jPasswordField1.setBackground(Color.red);
            if(jCheckBox2.isSelected()){
                
                jTextArea1.append("\n\nÍrja be a jelszót az első jelszó mezőbe\nMajd kattintson duplán a dekódolandó szöveges üzenet fájlon.");
                return;
            }
            jTextArea1.append("\n\nTitkosított szöveges üzenet létrehozása olvashatósági időkorláttal.\n"
                    + "\nAz olvashatóság időkorlát a jelülőnégyzet alatti legördülő listában állíthatja be.\n"
                    + "Az a létrehozás rendszeridejátől számított, nem veszi figyelembe az eltárő időzónákat.\n"
                    + "Ezt kérem vegy figyelembe a beállításánál. Ne használjon ékezetes karaktereket\n"
                    + "Az üzenet a munkakönyvtárba kerül lementésre innen az önnek tetsző csatornán továbbíthatja\n"
                    + "a címzettnek.(e-mail,msn...)\n"
                    + "Az üzenet védelmére, jelszót kell megadnia\n"
                    + "Visszakódolásakor annak tartalmát az üzenetablakban jeleníti meg a Kriptova\n"
                    + "Nem készül belőle kibontott állomány. A megjelnítés után törlésre kerül a kódolt üzenet\n"
                    + "Az időkorlát lejárta után az üzenet nem jeleníthető meg, \n azt automatikusan törli a program a megnyitási próba alkalmával.");
            jTextArea2.setText("Ide írhatja az üzenet szövegét, írja be a jelszót kétszer, nyomja meg a kódolás gombot.");
            
        }else{
            jComboBox7.setEnabled(false);
            jCheckBox4.setEnabled(true);
            roviduzenet=false;
             jTextArea1.append("\n\nTitkosított szöveges üzenet létrehozása funkció kikapcsolva");
              jTextArea2.setText("");
        
        }
        jPasswordField1.setBackground(Color.white);
    }//GEN-LAST:event_jCheckBox9ActionPerformed

    private void jButton16ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton16ActionPerformed
        // TODO add your handling code here:
        if(jCheckBox5.isSelected()){
            try {
                list1.removeAll();
                doboz.seek(fejlecpointer);
                kontfejlecbeolvas();
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }else {
        }
    }//GEN-LAST:event_jButton16ActionPerformed

    private void jTextPane1MouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTextPane1MouseEntered
        // TODO add your handling code here:
         if("".equals(jTextPane1.getText()))return;
         ki=true;
        try {
             sorbanall();
                if(hozzaad){
                    if(sorbaall());
                       else{
                           hozzaad=false;
                           sorbolki();
                           return;
                       }
                }    
            bedobott();
            sorbolki();
            if(jCheckBox11.isSelected()){
                    kontenerlezar();
                    System.exit(0);
            }       
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
       
    }//GEN-LAST:event_jTextPane1MouseEntered

    private void jCheckBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBox2ActionPerformed
        // TODO add your handling code here:
        if(roviduzenet){
            if(jCheckBox2.isSelected()){
                jTextArea1.append("\n\nÍrja be a jelszót az első jelszó mezőbe, majd");
                jTextArea1.append("\nKattintson duplán a dekódolandó üzenet fájlon.");
                jPasswordField1.setBackground(Color.red);
                return;
            }
            else{
                jTextArea1.append("\n\nKikapcsolta a szöveges üzenet dekódolás módot;");
            }
        }
        jLabel1.setText("          Válassza ki a fájlt");
        jLabel1.setForeground(Color.black);
        jPasswordField1.setBackground(Color.white);
        jPasswordField2.setBackground(Color.white);
        if(jCheckBox2.isSelected()){
            jTextArea1.append("\n\nKattintson duplán a dekódolandó fájlon.\n\n"
                + "Ha Fájl_Fájlal dekódolást használ akkor jelölje be a Fájl_Fájl kódolást alul.");
            jButton1.setText("Dekódolás");
        }
        else {
            jTextArea1.append("\nDekódolás kikapcsolva");
            jButton1.setText("Kódolás");
        }
    }//GEN-LAST:event_jCheckBox2ActionPerformed

    private void jButton19ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton19ActionPerformed
        // TODO add your handling code here:konténerfájl régebbi verzióba történő visszaállítása
        if(!kkopen)return;
        if(!"false".equals(kontenernev))kontenerlezar();
        if(helyreallit==0){
        jTextArea1.setText("");
        jTextArea1.append("\nHa a konténerfájl írás hiba miatt megsérült akkor az idxold alkönyvtárban található állományok\n"
                + "segítségével megpróbálhat visszaállítani egy, korábbi állapotot.\n"
                + "A sérülés jele ha a jól beállított paraméterekkel, jó kulccsal, jelszóval a megnyitásig eljut\n"
                + "de nem jelenik meg a tartalom, vagy a megnyitás után hibával kilép, olvashatatlanok a nevek...\n"
                + "\nA mégsem gombbal, visszavonhatja a megkezdett műveletet.\n"
                + "A folytatáshoz kattintson duplán a sérült konténerfájlon.");
        helyreallit++;
        }
        else if(helyreallit==1){
            javitando=jFileChooser1.getSelectedFile().getAbsolutePath();
            kontenernev=jFileChooser1.getSelectedFile().getName();
            jTextArea1.append("\n\nHa megfelelő a konténer amit kiválasztott, akkor most vélassza ki, a javítófájlt\n"
                    + ",vagy még, újrakezdheti-törölheti a műveletet a mégsem gomb megnyomásával\n"
                    + "Konténer neve: "+javitando);
            helyreallit++;
        }else if(helyreallit==2){
            javito=jFileChooser1.getSelectedFile().getAbsolutePath();
             jTextArea1.append("\n\nHa megfelelő a javitókód amit kiválasztott, akkor most a Hibajavítás gomb újbóli\n megnyomásával kezdheti a javítást"
                    + ",vagy még, újrakezdheti-törölheti a műveletet a\n mégsem gomb megnyomásával"
                     + "\nJavítófájl: "+javito);
             helyreallit++;
        }else if(helyreallit==3){
            jTextArea1.append("\nA hibajavítás megkezdődött... ");
            hibajavitas();
            jTextArea1.append("\nA hibajavítás befejezdődött... ");
            helyreallit=0;
        }
    }//GEN-LAST:event_jButton19ActionPerformed

    private void list2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_list2MouseClicked
        // TODO add your handling code here:
    }//GEN-LAST:event_list2MouseClicked

    private void list2MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_list2MouseMoved
        // TODO add your handling code here:
    }//GEN-LAST:event_list2MouseMoved

    private void jComboBox9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox9ActionPerformed
        // TODO add your handling code here: konténer lista sorrend
        //if(jComboBox9.getSelectedIndex()!=0)jButton8.setEnabled(false);
        //else jButton8.setEnabled(true);
        if(kontener){
            int db=list1.getItemCount();
                 
                 boolean [] flag=new boolean[500];
                 String [] nev = new String[500];
                 long [] point = new long [500];
                 for(int y=0;y<db;y++){
                 nev[y]=kontfajlnev[y];
                 flag[y]=kontflag[y];
                 point[y]=konpoint[y];
                 
                 }
                 if(jComboBox9.getSelectedIndex()==0){                //természetes sorrend
                        try {
                        list1.removeAll();
                        doboz.seek(fejlecpointer);
                        kontfejlecbeolvas();
                        } catch (IOException ex) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
                 
                 }else if(jComboBox9.getSelectedIndex()==1){
                //név szerinti rendezés
                
                //kontfajlnev;
                for (int i = db; i >= 2; --i) { 
                    for (int j = 0; j < i - 1; ++j) { 
                        //if (kontfajlnev[j].compareTo(kontfajlnev[j+1]) == 0);
                        if ((nev[j].compareTo(nev[j+1])) > 0)
                        { 
                            String tmp = nev[j]; 
                            nev[j] = nev[j + 1];
                            nev[j + 1] = tmp; 
                            long tmp1 = point[j]; 
                            point[j] = point[j + 1];
                            point[j + 1] = tmp1;
                            boolean tmp3 = flag[j]; 
                            flag[j] = flag[j + 1];
                            flag[j + 1] = tmp3;
                        }
                    }
                }
                list1.removeAll();
                for(int i=0;i<db;i++){
                    
                         if(flag[i])list1.add(nev[i]);
                    
                }
            
            }else if(jComboBox9.getSelectedIndex()==2){
                //méret szerinti rendezés
                for (int i = db; i >= 2; --i) { 
                    for (int j = 0; j < i - 1; ++j) { 
                        
                        if( point[j] > point[j+1] ){
                            
                            String tmp = nev[j]; 
                            nev[j] = nev[j + 1];
                            nev[j + 1] = tmp; 
                            long tmp1 = point[j]; 
                            point[j] = point[j + 1];
                            point[j + 1] = tmp1;
                            boolean tmp3 = flag[j]; 
                            flag[j] = flag[j + 1];
                            flag[j + 1] = tmp3;
                        }
                    }
                }
                list1.removeAll();
                for(int i=0;i<db;i++){
                    
                        if(flag[i])list1.add(nev[i]);
                    
                }
            }
        
        }else{
             jTextArea1.append("\nKonténer megnyitása után funkcionál ");
        }
    }//GEN-LAST:event_jComboBox9ActionPerformed

    private void list1KeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_list1KeyReleased
        // TODO add your handling code here:
        listaeleme();
    }//GEN-LAST:event_list1KeyReleased
        
    
       /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewApplication.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new NewApplication().setVisible(true);
        });
       
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton10;
    private javax.swing.JButton jButton11;
    private javax.swing.JButton jButton12;
    private javax.swing.JButton jButton13;
    private javax.swing.JButton jButton14;
    private javax.swing.JButton jButton15;
    private javax.swing.JButton jButton16;
    private javax.swing.JButton jButton19;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButton7;
    private javax.swing.JButton jButton8;
    private javax.swing.JButton jButton9;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox10;
    private javax.swing.JCheckBox jCheckBox11;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JCheckBox jCheckBox3;
    private javax.swing.JCheckBox jCheckBox4;
    private javax.swing.JCheckBox jCheckBox5;
    private javax.swing.JCheckBox jCheckBox6;
    private javax.swing.JCheckBox jCheckBox7;
    private javax.swing.JCheckBox jCheckBox8;
    private javax.swing.JCheckBox jCheckBox9;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JComboBox<String> jComboBox2;
    private javax.swing.JComboBox<String> jComboBox3;
    private javax.swing.JComboBox<String> jComboBox4;
    private javax.swing.JComboBox<String> jComboBox5;
    private javax.swing.JComboBox<String> jComboBox6;
    private javax.swing.JComboBox<String> jComboBox7;
    private javax.swing.JComboBox<String> jComboBox8;
    private javax.swing.JComboBox<String> jComboBox9;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPasswordField jPasswordField1;
    private javax.swing.JPasswordField jPasswordField2;
    private javax.swing.JPasswordField jPasswordField3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextPane jTextPane1;
    private java.awt.List list1;
    private java.awt.List list2;
    // End of variables declaration//GEN-END:variables

    private void streamclos1() {
        try {
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            kodolando.close();
            //jTextArea1.append("\nFájl: Input lezárva\n");
            //kodolt.close();
        } catch (IOException ex) {
            jTextArea1.append("\nFájl: lezársi hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
     private void streamclos2() {
        try {
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            //kodolando.close();
            //jTextArea1.append("\nFájl: Output lezárva\n");
            kodolt.close();
        } catch (IOException ex) {
            jTextArea1.append("\nFájl: lezársi hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void ftorol() throws FileNotFoundException {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
         kezd();
                if(Inputnyitott)streamclos1();
                //felülírom a kodolt fájlt
                DataOutputStream atir;
                
                atir = new DataOutputStream(new FileOutputStream(jFileChooser1.getSelectedFile()));
                //long hossza=jFileChooser1.getSelectedFile().length();
                jTextArea1.append("\nFájl: Output megnyitva");
                byte [] ezzel = null;
                ezzel =new byte[50000];
                int a=0;
                for(int i=0;i<ezzel.length-1;i++)ezzel[i]=generator();
                do{
                    
                    try {
                        atir.write(ezzel);
                    } catch (IOException ex) {
                        jTextArea1.append("\nFájl: írási hiba");
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    a++;
                }while(a<20000);//1GB van felülírva
        try {
            atir.close();
            jTextArea1.append("\nFájl: felülírva");
            //return;
        } catch (IOException ex) {
            jTextArea1.append("\nFájl: lezársi hiba felülírás után ");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //törlöm a felülírt fájlt
        File torol;
        
        torol = new File(jFileChooser1.getSelectedFile().getAbsolutePath());
        torol.delete();
        
        jTextArea1.append("\nFájl:" +jFileChooser1.getSelectedFile().getAbsolutePath()+" törölve");
        vegez();
        jFileChooser1.rescanCurrentDirectory();
    }

   /* private void log() {
        
       
        try {
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            
            RandomAccessFile belog = null;
            
            try {
                if(jCheckBox6.isSelected()){
                    belog = new RandomAccessFile("F"+logtxt,"rw");
                }else belog = new RandomAccessFile(logtxt,"rw");
                
            } catch (FileNotFoundException ex) {
                jTextArea1.append("\nNem találom: "+logtxt);
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            long beloghossz = belog.length();
            
            //
            
            belog.seek(beloghossz);
            
            String trim = kodoltneve.trim();
            kodoltneve=trim+"\n";
            
            //itt lehet titkosítani
            
            belog.writeBytes(kodoltneve);
            belog.close();
           
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }*/

    private void kulccsal() throws IOException {
        
        try {
            bajt = kodolando.available();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //adatgyujtes
        //jTextArea1.setText("");
        long tol;
         Calendar cal = Calendar.getInstance();
        tol = cal.getTimeInMillis();
        try {
            //jTextArea1.append("Fájl eredeti neve: "+jFileChooser1.getSelectedFile().getName()+"\n");
            jTextArea1.append("Fájl eredeti helye: "+jFileChooser1.getSelectedFile().getPath()+"\n");
            jTextArea1.append("Fájl kodneve: "+kodoltneve+"\n");
            jTextArea1.append("Fájl méret: "+String.valueOf((float)(kodolando.available())/1024/1024)+" Mbájt \n");
            
            //jTextArea1.append("\nKezdési idő: "+cal.getTime());
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
        try {
            //kimenet nyitása
            kodolt = new DataOutputStream(new FileOutputStream(kodoltneve));
            //jTextArea1.append("\n "+kodoltneve+" fájl megnyitva");
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            jTextArea1.append("\n "+kodoltneve+" fájl megnyitása sikertelen");
        }
        ///kodolás
        
        byte [] key;
        byte [] olv;
        byte [] ir;
                
        int olvhossz = 0;
        
        try {
            olvhossz = kodolando.available();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        int buff=1000000;
        key=new byte[buff];
         ir = new byte[buff];
        olv = new byte[buff];
        int i;
        int a=jComboBox1.getSelectedIndex();
        int b=jComboBox2.getSelectedIndex();
        int c=jComboBox3.getSelectedIndex();
        int d=jComboBox4.getSelectedIndex();
        int e;
        
        
        boolean vege=true;
        while(kodolando.available()>0){
            if(kodolando.available()<1000000 && vege){buff=100000;olv=new byte[buff];ir=new byte[buff];key=new byte[buff];vege=true;}
            if(kodolando.available()<100000 && vege){buff=10000;olv=new byte[buff];ir=new byte[buff];key=new byte[buff];vege=true;}
            if(kodolando.available()<10000 && vege){buff=5000;olv=new byte[buff];ir=new byte[buff];key=new byte[buff];vege=true;}
            if(kodolando.available()<5000 && vege){buff=2500;olv=new byte[buff];ir=new byte[buff];key=new byte[buff];vege=true;}
            if(kodolando.available()<2500 && vege){buff=1;olv=new byte[buff];ir=new byte[buff];key=new byte[buff];vege=false;}
                try {
                    kodolando.read(olv);
                } catch (IOException ex) {
                    jTextArea1.append("\nkodolandó: olvasási hiba");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                       
                
                try {
                    kulcs.read(key);
                } catch (IOException ex) {
                    jTextArea1.append("\nkulcs: olvasási hiba: kulcsfály min 1 MB-os legyen");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                if(kulcs.available()<buff){
                    
                    kulcs.close();
                    kulcs = new DataInputStream(new FileInputStream(kulcs1));
                }
             
                
                    for(i=0;i<buff;i++){
                        e=(a^b)^(c^d);
                        ir[i]=(byte) ((byte) (olv[i]^key[i])^e);
                    }                    
                    
              
                try {
                    kodolt.write(ir);

                //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
                } catch (IOException ex) {
                    jTextArea1.append("\nkódolt írási hiba");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
            
        
        }
        kulcs.close();
        kodolando.close();
        kodolt.close();
        if(jCheckBox1.isSelected()){
            try {
                ftorol();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        long ig;
        cal = Calendar.getInstance();
        ig = cal.getTimeInMillis();
        long eredmeny=ig-tol;
        
        jTextArea1.append("\nVége: "+cal.getTime());
        jTextArea1.append("\nVégrehajtási idő sec : "+String.valueOf(eredmeny/1000));
        //double speed;
        double mb = (olvhossz/1024/1024);
        jTextArea1.append("\nEredmény : "+String.valueOf(mb/(eredmeny/1000))+" MB/sec");
        jCheckBox2.setEnabled(true);
        jCheckBox2.setSelected(false);
        jButton1.setText("Kódolás");
         jFileChooser1.rescanCurrentDirectory();
        
        //if(jCheckBox3.isSelected() && !jCheckBox2.isSelected())log();
        
    }

    private void Kulcsfajlnyitas() {
        
        
        
        try {            
            kulcs1=jFileChooser1.getSelectedFile();
            kulcs = new DataInputStream(new FileInputStream(kulcs1));
            jTextArea1.append("\nFájl:Kulcs fájl megnyitva, mérete Mb:"+String.valueOf((kulcs.available())/1024/1024));
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (FileNotFoundException ex) {
            jTextArea1.append("\nFájl:Kulcs fájl megnyitása nem sikerült");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            jTextArea1.append("\nFájl:Kulcs fájl olvasása nem sikerült");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        jTextArea1.append("\nVálassza ki a kódolandó fájlt");
        kulcsolt=true;
    }

   /* private void logbolkeres() {
    try {
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            
            
            
            
            RandomAccessFile belog = null;
            
            try {
                if(jCheckBox6.isSelected()){
                    belog = new RandomAccessFile("F"+logtxt,"r");
                }
                else belog = new RandomAccessFile(logtxt,"r");
            } catch (FileNotFoundException ex) {
                jTextArea1.append("\nNem találom: "+logtxt);
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            //long beloghossz = belog.length();
            //byte [] olvas = new byte[beloghossz];
                    //belog.read(olvas);
                    //belog.close();
            //byte [] olvasstr;
            //belog.seek(beloghossz);
            
            String trim;
            String mihez;
            boolean tudkiolvasniadatot=false;
            int kodoltnevhossz;
            int sorhossz;
             //kodoltneve=trim+"\n";
            long i=0;
            while(belog.length()>i){ 
                trim=belog.readLine();
                //itt lehet visszafejteni
                //jTextArea1.append("\n"+trim);
                //string tördelése
                kodoltnevhossz=trim.indexOf("^^");
                sorhossz=trim.length();
                kodoltneve=trim.substring(kodoltnevhossz+2, sorhossz);
                
                if(kodnev.equals(trim.substring(0, kodoltnevhossz))){
                    //jTextArea1.append("\n"+kodoltneve);
                    
                    mihez=kodoltneve;
                    belog.close();
                    kodoltneve=mihez.replace("kripta",".");
                    String pwhossz=mihez.replace("kripta",".");
                    kodoltnevhossz=kodoltneve.indexOf("_+_");
                    pwhossz=pwhossz.substring(kodoltnevhossz+3, pwhossz.length());
                    kodoltneve=kodoltneve.substring(0, kodoltnevhossz);
                    
                    jTextArea1.append("\n\nFájl eredeti neve:"+kodoltneve);
                    jTextArea1.append("\nFájl titkosíítás paraméterei.\nJelszóhossz,jelszóemlékeztető,pin1,pin2,pin3,pin4:\n\t "+pwhossz.replace("_",",")+"\n");
                    if(jCheckBox6.isSelected()){
                        jTextArea1.append("\nKulcsforgatás bekapcsolásával titkosított");
                    }else jTextArea1.append("\nNem kulcsforgatás bekapcsolásával titkosított");
                    return;
                }
                i=belog.getFilePointer();
            }
            belog.close();
            if(!tudkiolvasniadatot && logbk<2){
                logbk++;
                logkodolas();
                if(jCheckBox6.isSelected()){
                    jCheckBox6.setSelected(false);
                    logkodolas();
                }
                else {
                    jCheckBox6.setSelected(true);
                    logkodolas();
                }
                logbolkeres();
                return;
                
            }
            if(!tudkiolvasniadatot && logbk>1)jTextArea1.append("\n\nA fájról nem tadtam adatot nyerni. Nem ezzel a mesterkulccsal vagy inditási\n"
                    + "pinbeállítással lett a titkosítás elvégezve .");
            
           
        } catch (IOException ex) {
            jTextArea1.append("\nAdatkeresési hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
//throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }*/

    private void logkeynyit() {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
            RandomAccessFile belog = null;
            
             jTextArea1.setText("");
            if(!kkopen){
               
                jTextArea1.append("\nVálassza ki a mesterkulcsot (alapból valamilyenszamkriptova.key)");
                jTextArea1.append("\nVagy generáljon újat 7.7.7.160000 pin beállításával és egy mesterjelszó (minimum 8 karakter)\n"
                        + "megadásával, majd Rezet-Mégse gomb megnyomásával. Az új kulcs neve xxxxxxxxxxxxxkriptova.key\na munkamappába lesz megtalálható.  A kulcsot"
                        + " tartsa biztos helyen. "
                        + "\nAz új kulccsal másik kulccsal titkosított fájlokhoz, konténerekhez nem tud hozzáférni.\n"
                        + "\n\n\n\n-------------------indítási pin beállítása----------------------------------------itt------------itt-----------itt----------itt");
                return;
            
            }
            
            try {
                belog = new RandomAccessFile(jFileChooser1.getSelectedFile(),"r");
               
            } catch (FileNotFoundException ex) {
                
                
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        try {
            
            kriptovakey = new byte[250];
            mestercrc=belog.readLong();//crc beolv ell
            
            belog.read(kriptovakey);
            //belog.writeLong(Arrays.hashCode(kriptovakey));
            long kulcshash=belog.readLong();
            if(kulcshash!=Arrays.hashCode(kriptovakey)){
                jButton7.setEnabled(false);
                jTextArea1.append("\nEz az állomány nem mesterkulcs...\nÖnmegsemmisítés bekapcsolva");
                jCheckBox8.setSelected(true);
                return;
            }else jButton7.setEnabled(true);
            //logtxt=belog.readUTF();
            
            
            //logfile ell ha kell létrehozni a munkakönyvtárba
           /* DataInputStream logellenor = null;
            DataInputStream klogellenor = null;
            try{
                
                    klogellenor=new DataInputStream(new FileInputStream("F"+logtxt));
                     logellenor=new DataInputStream(new FileInputStream(logtxt));
            }catch(IOException ex){
                DataOutputStream logklonozo;
                DataOutputStream klogklonozo;
                
                 klogklonozo=new DataOutputStream(new FileOutputStream("F"+logtxt));
                 logklonozo=new DataOutputStream(new FileOutputStream(logtxt));
                jTextArea1.append("\n\nA megnyitott mesterkulcshoz tartozó: "+logtxt+" és F"+logtxt+" fájlt létrehoztam a \nmunkakönyvtárba."
                        + "A munkakönyvtár, ahonnan a kriptova programot indította. Ide menti a program a tikosított fájlokat.\nVIGYÁZZON ezek csak az ebbe a könyvtárba mentett fájlok adatait \nfogja tartalmazni! "
                        + "NE ÍRJON FELÜL VELE MÁS KÖNYVTÁRBAN ILYEN NÉVEN LÉVŐT, HA MÁR \nAZ TARTALMAZ ADATOKAT, MERT AZOK OTT KELLENEK AZ ADATOK VISSZAFEJTÉSÉHEZ.\n\nAdja meg a mesterjelszót");
                jTextArea1.setBackground(Color.red);
                jTextArea1.setForeground(Color.black);
                logklonozo.close();
                klogklonozo.close();
            }
            logellenor.close();
            klogellenor.close();
            jFileChooser1.rescanCurrentDirectory();*/
            jTextArea1.setBackground(Color.red);
            jTextArea1.setForeground(Color.black);
            jTextArea1.append("\nBiztonsági indítás\nAdja meg a mesterjelszót!");
           
            
            //for(int i=0;i<250;i++)jTextArea1.append(String.valueOf((char)kriptovakey[i]));
        } catch (IOException ex) {
            jTextArea1.append("\nKulcs nem olvasható");
            jTextArea1.setBackground(Color.getHSBColor(generator(), generator(), generator()));
             jTextArea1.setForeground(Color.black);
            kkopen=false;
                try {
                    belog.close();
                } catch (IOException ex1) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                }
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            belog.close();
        } catch (IOException ex) {
             jTextArea1.append("\nKulcs nem zárható");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

/*    private void logkodolas() {
        
        DataInputStream logolvaso;
        DataOutputStream logiro;
        //kulcs forgatva legyen a kódoláshoz
        if(forgatasbe);
        else kulcsforgatas();
            
        
        try {
            if(jCheckBox6.isSelected()){
                logolvaso = new DataInputStream(new FileInputStream("F"+logtxt));
            }else logolvaso = new DataInputStream(new FileInputStream(logtxt));
            try {
            byte [] logkodolo;
            int loghossz = logolvaso.available();
            logkodolo = new byte[logolvaso.available()];
            logolvaso.read(logkodolo);
            int c=0;
            for(int a=0;a<loghossz;a++){
                if(c>249)c=0;
                logkodolo[a]=(byte) (logkodolo[a]^kriptovakey[c]);
                c++;
            }
            logolvaso.close();
            if(jCheckBox6.isSelected()){
                logiro = new DataOutputStream(new FileOutputStream("F"+logtxt));
            }
            else logiro = new DataOutputStream(new FileOutputStream(logtxt));
            logiro.write(logkodolo);
            logszamlalo++;
            logiro.close();
            System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length);
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }    
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
    }*/

    private void kontenergeneralas() {
        long crc=0;
        String pwstring=jPasswordField3.getText();
        int pwhossz=pwstring.length();
        if(pwhossz<8){jTextArea1.append("\nRövid jelszó: min 8 karakter");jTextArea1.setBackground(Color.red);return;}
        for(int a=0;a<pwhossz;a++){crc=crc+(int)pwstring.charAt(a);}
        
        DataOutputStream konteneruj = null;
        String fileneve="kont_"+String.valueOf(generator()+"_"+generator()+"."+pinor);
        try {
            konteneruj=new DataOutputStream(new FileOutputStream(fileneve));
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (FileNotFoundException ex) {
            jTextArea1.setBackground(Color.red);
            jTextArea1.append("\nKontener fájl megnyitási hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            //crc kiirás
            konteneruj.writeLong(crc);
        } catch (IOException ex) {
            jTextArea1.setBackground(Color.red);
            jTextArea1.append("\nKontener fájl crc írási hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            //mastkey hash és a pi hash
            String konthash= (String.valueOf(jComboBox1.getSelectedIndex())+String.valueOf(jComboBox2.getSelectedIndex())+String.valueOf(jComboBox3.getSelectedIndex())+String.valueOf(jComboBox4.getSelectedIndex()));
            long konth=konthash.hashCode()+pinor;
            konteneruj.writeLong(konth);
        } catch (IOException ex) {
             jTextArea1.setBackground(Color.red);
            jTextArea1.append("\nKontener fájl hash írás hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //kulcsgenerálás
        byte [] konkey=new byte[(jComboBox4.getSelectedIndex()+1)*20000];
        for(int a=0;a<konkey.length;a++)konkey[a]=generator();
        try {
            //kulcskiirás
            konteneruj.write(konkey);
        } catch (IOException ex) {
            jTextArea1.setBackground(Color.red);
            jTextArea1.append("\nKontener fájl kulcs írási hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            konteneruj.writeBoolean(true);//irás szemafor alapban engedélyezett
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        try {
            konteneruj.close();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        jTextArea1.append("\nKonténer fájl kész.");
        DataOutputStream sor = null;
        try {
            sor=new DataOutputStream(new FileOutputStream(fileneve+".sor"));
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        long [] sorban=new long[sorbanalhatnak];
        for(int i=0;i<sorbanalhatnak;i++){
            sorban[i]=0;
        }
        try {
            for(int i=0;i<sorbanalhatnak;i++)sor.writeLong(sorban[i]);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
         jFileChooser1.rescanCurrentDirectory();
        
    }

    private void kontenertnyit() {
        
        /*    if(jCheckBox6.isSelected()){
                jTextArea1.append("\nKulcsforgatási funkció aktív lesz a konténer megnyitása után");
                jLabel17.setText("Kulcs forgatás be");
            }else jLabel17.setText("Kulcs forgatás ki");*/
            dobozszabadhely = jFileChooser1.getSelectedFile();
            
            
           
            
            //ell.delete();
            try {
                doboz = new RandomAccessFile(jFileChooser1.getSelectedFile(),"rw");
            } catch (FileNotFoundException ex) {
                jTextArea1.append("\nFájl megnyitási hiba");
                jTextArea1.setBackground(Color.red);
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            try {
                mestercrc=doboz.readLong();
            } catch (IOException ex) {
                jTextArea1.append("\n crc olvasási hiba");
                jTextArea1.setBackground(Color.red);
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
                String konthash= (String.valueOf(jComboBox1.getSelectedIndex())+String.valueOf(jComboBox2.getSelectedIndex())+String.valueOf(jComboBox3.getSelectedIndex())+String.valueOf(jComboBox4.getSelectedIndex()));
                long konth=konthash.hashCode()+pinor;
                
                if(!jCheckBox8.isSelected())
                    
                    {
                        try{
                            long ellenor=doboz.readLong();
                            if(ellenor!=konth){
                            doboz.close();
                            jTextArea1.setText("");
                            jTextArea1.append("\n Nem megfelelő konténerbeállítás");
                             kny=0;
                            jTextArea1.append("\nA konténer lezárva maradt\nPróbálja beállítani a megfelelő konténer pint.\n"
                                    
                                    + "Ellenőrizze, hogy a HKód egyezik-e a konténerfájl nevének végén szereplő kóddal.\n"
                                    + "Ha nem akkor más a program indítási pin, vagy más mesterkulcshoz tartozik a konténer");
                            kontenerlezar();
                            return;
                            }
                        }catch(IOException ex){
                            jTextArea1.setText("");
                            jTextArea1.append("\n Nem megfelelő konténerbeállítás, talán kompatibilitási probléma.\n");
                            try {
                                doboz.close();
                            } catch (IOException ex1) {
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                            }
                             kny=0;
                            jTextArea1.append("\nA konténer zárva maradt");
                            jTextArea1.setBackground(Color.red);
                            return;
                        }
                       
                    }
                kontenerkey=new byte[(jComboBox4.getSelectedIndex()+1)*20000];
            try {
                
                int a=0;
                int i=0;
                byte kontenerpin;
                
                kontenerpin = 0;
                kontenerpin=(byte) (jComboBox1.getSelectedIndex()^jComboBox2.getSelectedIndex()^jComboBox3.getSelectedIndex()^jComboBox4.getSelectedIndex());
                boolean alappin=false;
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                //if(jCheckBox6.isSelected())kfbe=true;
                kfbe=false;
                int forgatas=0;
                doboz.read(kontenerkey);
                while(a<kontenerkey.length-1){
                    if(i>kriptovakey.length-1 || forgatas==0){
                        i=0;
                        /*if(jCheckBox6.isSelected()){
                            
                           if(forgatas==0)kulcsforgatas();
                           else if(forgatas==1)kulcsforgatas2();
                           else if(forgatas==3)kulcsforgatas3();
                           forgatas++;
                           if(forgatas>3)forgatas=0;
                        } */   
                    }
                    if(alappin){
                         
                        kontenerkey[a]=(byte) (kontenerkey[a]^kriptovakey[i]);
                    }
                    else{
                        
                        kontenerkey[a]=(byte) ((byte) (kontenerkey[a]^kriptovakey[i])^kontenerpin);
                    } 
                    a++;i++;    
                              
                }
                if(alappin){
                         list1.setBackground(Color.black);
                        list1.setForeground(Color.yellow);
                      
                    }
                    else{
                        list1.setBackground(Color.black);
                        list1.setForeground(Color.red);
                    } 
                
                
            } catch (IOException ex) {
                jTextArea1.append("\n kulcs olvasási hiba");
                try {
                    doboz.close();
                    kontenerlezar();
                } catch (IOException ex1) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                }
                jTextArea1.setBackground(Color.red);
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length-1);//indítási alapra allitom a kriptovakeyt   
        try {
           szemafor=doboz.readBoolean();
        } catch (IOException ex) {
            jTextArea1.append("\n szemafor olvasási hiba");
                try {
                    doboz.close();
                } catch (IOException ex1) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                }
            kontenerlezar();
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            //jTextArea1.append("\nKonténer Pointer megnyitás után: "+String.valueOf(doboz.getFilePointer()));
            fejlecpointer=doboz.getFilePointer();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        jTextArea1.append("\n\nAdja meg a konténer jelszavát!");
        jLabel5.setText("Konténer jelszava");
        jTextArea1.setBackground(Color.red);
        jPasswordField3.setBackground(Color.red);
      //  throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void kontfejlecbeolvas() {
        
        
        
            
            kontflag=new boolean[500];
            konpoint=new long[500];
            kontfajlnev=new String[500];
            if(!jCheckBox8.isSelected())kontfilenevhossz=100;
            else kontfilenevhossz=50;
            filenevkiolvaso=new char [kontfilenevhossz];
        felszabadithatohely=0;   
        szamol=0;
        tj=0;   
        
             
        try {
           // jTextArea1.append("\nKonténerben : ");
            //jTextArea1.append("\nKonténer jelenlegi mérete : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
            jLabel6.setText("\nKonténer mérete : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
           // long fejlecpointer=doboz.getFilePointer();
           //if(jCheckBox6.isSelected())list1.add("******  Kulcsforgatás bekapcsolva ****** kikapcs:pipa ki és pinállítás");
            while(doboz.length()>doboz.getFilePointer() && szamol<500){
                //jTextArea1.append("."+String.valueOf(szamol));
                long javitasipont=doboz.getFilePointer();
                kontflag[szamol]=doboz.readBoolean();//ha vége a fájlnok itt kilép?
                 
                
                for(int i=0;i<kontfilenevhossz;i++){
                    filenevkiolvaso[i]=' ';
                    filenevkiolvaso[i]=(char) doboz.readChar();
                    if(filenevkiolvaso[i]!=' ')filenevkiolvaso[i]=(char) (filenevkiolvaso[i]^kriptovakey[i]);
                    
                }
                 //itt kellene ellenorizni, hogy csak azokat a tételeket listázza amik az aktuális mesterkulccsal lettek kódolva
                 //megoldva: csak egy mesterkulccsal vagy pin beállítással nyílik meg a hozzadad() miatt 
                 
               
                kontfajlnev[szamol]=String.valueOf(filenevkiolvaso);//átírom a fájlnevet sztringbe
                
             /*    int e=kontfajlnev[szamol].indexOf("_DATE_");
                    if(e<0){
                        jTextArea1.append("\nNem a választott mesterkulccsal olvasható a konténer tartalma");
                        kontenerlezar();
                        kursor(0);
                        return;
                    
                    }*/
                
                //if(!nyitasproba()){mesterkucshoztartozik=false;jTextArea1.append("\nNem megfelelő a beállított a pin?");kontenerlezar();return; }
                if(kontflag[szamol]){list1.add(kontfajlnev[szamol]);}//hozzáadom a fájlistához ha nincsen törlésre jelölve
                 
                //pinnel is titkosítható a következő fájl kezdőhelye
                
                boolean alappin=false;
                byte kompointkod=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                if(alappin){
                         
                        konpoint[szamol]=doboz.readLong();
                    }
                    else{
                        
                        konpoint[szamol]=doboz.readLong()^kompointkod;
                    } 
                
                
                
                if(!kontflag[szamol])felszabadithato();
                if(doboz.getFilePointer()+konpoint[szamol]>doboz.length()){
                
                    
                    
                    jTextArea1.append("\nA konténer valószínüleg, írás alatt áll. "+String.valueOf(javitasipont)+" bájt \n");
                    jTextArea1.append("\nA Frissítés gommbbal ellenőrízheti, hogy változik e a mérete\n"
                            + "Ha nem akkor a konténer sérült lehet, ne kezdjen írási műveletet.");
                    //hiba=true;
                   /* if(szamol>1){
                        jTextArea1.append("\nAutomatikus javítás...");
                        doboz.setLength(javitasipont);

                        try {
                            list1.removeAll();
                            doboz.seek(fejlecpointer-1);
                            doboz.writeBoolean(true);
                            kontfejlecbeolvas();
                        } catch (IOException ex) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        jTextArea1.append("\nAutomatikus javítás kész");
                        jTextArea1.append("\nA megkezdett feltöltés csonkolva lett\nA besorolási lista alaphelyzetbe állítva");
                    }else{
                        jTextArea1.append("\n\nVagy a konténerfájl nem kompatibilis verzió");
                        jTextArea1.append("\nA beavatkozás felhasználói döntést igényel\n"
                                + "használja a javítás funkciót.");
                    }
                   try {
                           
                            doboz.seek(fejlecpointer-1);
                            doboz.writeBoolean(false);
                            
                        } catch (IOException ex) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        
                    jTextArea1.append("\nA várakozási sorban állók kikapcsolása...");
                   //list1.add("\nA javítás vége...");
                   sorbanall();
                    sor.seek(0);
                    for(int i=0;i<sorbanalhatnak;i++){
                        sor.writeLong(0);
                        
                    }
                    sor.close(); */
                    szamol=501;
                     try {
                                doboz.seek(doboz.getFilePointer()-1);
                            } catch (IOException ex) {
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                if(!doboz.readBoolean()){

                                    doboz.writeBoolean(true);
                                   
                                } 
                            } catch (IOException ex) {
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                    return;
                    
                }
                else doboz.seek(doboz.getFilePointer()+konpoint[szamol]);// a következő olvasópozícióra állítom a fájlpointert
                
                             
                if(konpoint[szamol]>=doboz.length()){szamol++; return;}//elértem a konténerféjl végét az indexet növelem az új hozzáadásához
                
                jLabel11.setText("Foglalt: "+String.valueOf(list1.getItemCount()));
                jLabel14.setText("Maradt: "+String.valueOf(500-(tj+list1.getItemCount())));
                szamol++;
                //ugrastnemszamol=szamol+ugrastnemszamol;
            }
             if(szamol==499){jTextArea1.append("\n\nA konténer megtelt, tömörítsen vagy hozzon létre újjat");return;}//ennyi fért bele
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
          /*  jTextArea1.setText(" ");
            jTextArea1.append("\nRoszz a pin?");
            kontenerlezar();*/
            
            
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        

        jFileChooser1.rescanCurrentDirectory();
    }

    @SuppressWarnings("empty-statement")
    private void kontenerhezad() {
        
       /* try {
            jTextArea1.append("\nKonténer hozzáad előtt hossza : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            jTextArea1.append("\nKonténer Pointer : "+String.valueOf(doboz.getFilePointer()));
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }*/
       //kizárolagosan 1 valaki írhat ezt jelezni kell.
       
       indexlog();
        try {
            //boolean irhatok=true;
            // kell egy szabadhely vizsgélat a merevlemeznél
            eletjel();
        } catch (IOException ex) {
            jTextArea1.append("\nÉletjel");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
       szabadhely=dobozszabadhely.getFreeSpace();
       File ell=jFileChooser1.getSelectedFile();
       long faljmeret=ell.length();
       long dobozmeret=dobozszabadhely.length();
       jTextArea1.append("\n Szabad hely: "+String.valueOf(szabadhely/1024/1024)+" MB");
       jTextArea1.append("\n Fájl méret : "+String.valueOf(faljmeret/1024/1024)+" MB");
       if(szabadhely-(faljmeret+5000000)<0){
           jTextArea1.append("\n A kijelölt fájl konténerhez adása nem lehetséges a meghajtón lévő szabad hely hiánya miatt.");
           kimaradtdb++;
           kimaradmeret=kimaradmeret+faljmeret;
           kursor(0);
           return;
       }
      
        try { 
            doboz.seek(fejlecpointer-1); //szemaforra állok
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {//kiolvasom irja e valaki ha igen akkor átállítom 
            
                if(doboz.readBoolean()){
                    doboz.seek(doboz.getFilePointer()-1);
                    doboz.writeBoolean(false);
                }else{
                   jTextArea1.append("\n A Konténer írásra van jelölve"); 
                   return;
                
                } 
                
                /*else{
                    
                    if(jCheckBox10.isSelected()){
                        long varakozik=0;
                        kezd();
                        long k=kezdet;
                        switch (jComboBox8.getSelectedIndex()) {
                            case 0:
                                varakozik=1000*60;
                                break;
                            case 1:
                                varakozik=1000*60*3;
                                break;
                            case 2:
                                varakozik=1000*60*5;
                                break;
                            case 3:
                                varakozik=1000*60*10;
                                break;
                            case 4:
                                varakozik=1000*60*30;
                                break;
                            case 5:
                                varakozik=1000*60*60;
                                break;
                            case 6:
                                varakozik=1000*60*120;
                                break;
                            case 7:
                                varakozik=1000*60*180;
                                break;
                            default:
                                break;
                        }
                        list2.setBackground(Color.red);
                        list2.add("F");
                        list2.add("0");
                        list2.add("G");
                        list2.add("L");
                        list2.add("A");
                        list2.add("L");
                        list2.add("T");
                        voltfoglalt=true;
                        
                        while(k+varakozik>=kezdet){
                                kezd();
                                
                                doboz.seek(doboz.getFilePointer()-1);
                                if(doboz.readBoolean())break;
                               if(kezdet%(1000*60)==0)eletjel();             
                        }
                        list2.setBackground(Color.black);
                            doboz.seek(doboz.getFilePointer()-1);
                            if(doboz.readBoolean()){
                                doboz.seek(doboz.getFilePointer()-1);
                                doboz.writeBoolean(false);
                            }else{
                                jTextArea1.append("\nA konténer a megadott idő után is foglalt volt.");
                                return;
                            }
                            //frissítem azután, hogy más is írta
                             if(jCheckBox5.isSelected()){

                                list1.removeAll();
                                doboz.seek(fejlecpointer);
                                kontfejlecbeolvas();
          
                            }
                             szabadhely=dobozszabadhely.getFreeSpace();
                            ell=jFileChooser1.getSelectedFile();
                            faljmeret=ell.length();
                            dobozmeret=dobozszabadhely.length();
                            jTextArea1.append("\n Szabad hely: "+String.valueOf(szabadhely/1024/1024)+" MB");
                            jTextArea1.append("\n Fájl méret : "+String.valueOf(faljmeret/1024/1024)+" MB");
                            if(szabadhely-(faljmeret+5000000)<0){
                                jTextArea1.append("\n A kijelölt fájl konténerhez adása nem lehetséges a meghajtón lévő szabad hely hiánya miatt.");
                                kimaradtdb++;
                                kimaradmeret=kimaradmeret+faljmeret;
                                kursor(0);
                                return;
                            }
                             
                        
                    }
                   
                    
                    if(!jCheckBox10.isSelected()){
                        jTextArea1.append("\nA konténer írás alatt van, kérem próbálkozzon később");
                        hozzaad=false;
                        kursor(0);
                        return;
                    } 
                } */
            
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
               kezd();
                DataInputStream beolvas = null;
                kontflag[szamol]=true;
               
                konpoint[szamol]=jFileChooser1.getSelectedFile().length();// a hozzáadott fájl hossza a mutató ugratási száma
                kontfajlnev[szamol]=jFileChooser1.getSelectedFile().getName();
                
                Calendar c=Calendar.getInstance();
                String datum= c.getTime().toLocaleString();
                kontfajlnev[szamol]=kontfajlnev[szamol]+"_DATE_"+datum;
                
                // van pin beállítva rakjuk elé a pinelt jelölést
                
                if(jComboBox1.getSelectedIndex()!=0 || jComboBox2.getSelectedIndex()!=0 || jComboBox3.getSelectedIndex()!=0 || jComboBox4.getSelectedIndex()!=0){
                    
                    
                }
                for(int a=0;a<filenevkiolvaso.length;a++)filenevkiolvaso[a]=' ';
                //if(kfbe)kontfajlnev[szamol]="KFBE_"+kontfajlnev[szamol];
                //if(!jCheckBox7.isSelected())kontfajlnev[szamol]="1key_"+kontfajlnev[szamol];
                 for(int i=0;i<kontfajlnev[szamol].length();i++){
                     
                    filenevkiolvaso[i]=kontfajlnev[szamol].charAt(i);//stringből byte tömbbe
                    
                    //jTextArea1.append(String.valueOf(filenevkiolvaso[i]));
           
                }
                jTextArea1.append("\n"+String.valueOf(filenevkiolvaso)); //a hozzáírandó fájl neve
                for(int i=0;i<kontfajlnev[szamol].length();i++){if(filenevkiolvaso[i]!=' ')filenevkiolvaso[i]=(char) (filenevkiolvaso[i]^kriptovakey[i]);}
                //jTextArea1.append("\n"+kontfajlnev[szamol]);
                
                //itt kell megvizsgálni, hogy van-e ujrahasznosítható hely és oda állítani a doboz pointerét
                 boolean nemtalalthelyet=true;
               
        if(nemtalalthelyet)try {
            doboz.seek(doboz.length());
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //fejlécírás        
        try {
            doboz.writeBoolean(true);
            
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
            jTextArea1.append("\nirashiba1");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        try {
            doboz.writeChars(String.valueOf(filenevkiolvaso));
            for(int a=0;a<kontfilenevhossz;a++)filenevkiolvaso[a]=' ';
        } catch (IOException ex) {
            jTextArea1.append("\nirashiba2");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }

        try {
                boolean alappin=false;
                byte kompointkod=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                if(alappin){
                         
                        doboz.writeLong(jFileChooser1.getSelectedFile().length());
                    }
                    else{
                        
                        doboz.writeLong(jFileChooser1.getSelectedFile().length()^kompointkod);
                    }
            
            
            
        } catch (IOException ex) {
            jTextArea1.append("\nirashiba3");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
        try {
            beolvas=new DataInputStream(new FileInputStream(jFileChooser1.getSelectedFile()));
        } catch (FileNotFoundException ex) {
            jTextArea1.append("\nnyitáshiba kodolando");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        File meret = new File(jFileChooser1.getSelectedFile().getAbsolutePath());
        long hossza = meret.length();
        long szakasz = hossza/51L;
        long lepes = 51L;
        list2.removeAll();
        //fájlkódolás és hozzáfűzés
        byte [] beolvasva= new byte[(jComboBox4.getSelectedIndex()+1)*20000];//kulcsnyit olvas be buff méret
        try {
            int a=0;
           
            byte vege = 0;
            boolean cb7=jCheckBox7.isSelected(); //kétkulcsos kódolás
            int kriptovahossz=0;
            while(beolvas.available()>0){
               
              //if(jCheckBox6.isSelected())System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length-1);    
              
             
              
                               
                if(beolvas.available()>(jComboBox4.getSelectedIndex()+1)*20000){
                    
                     if(hossza<szakasz*lepes){
                            eletjel();
                            list2.add("V");
                            list2.select(list2.getItemCount()-1);
                            lepes--;
                            if(lepes<1)list2.removeAll();

                        }
                        hossza=hossza-beolvasva.length;

                    beolvas.read(beolvasva);
                    for(int i=0;i<kontenerkey.length-1;i++){
                         
                        if(cb7 && kriptovahossz<kriptovakey.length-1){ //ha be van kapcsolva a kétkulcsos titkosítás
                           
                            
                           beolvasva[i]=(byte) (beolvasva[i]^kriptovakey[kriptovahossz]);
                           kriptovahossz++;
                           if(i<kontenerkey.length-2)i++;
                           if(kriptovahossz>=kriptovakey.length-1)kriptovahossz=0;
                           
                        }   
                        beolvasva[i]=(byte) (beolvasva[i]^kontenerkey[i]);
                           
                        
                    }
                    doboz.write(beolvasva);
                    //if(jCheckBox6.isSelected())kulcsforgatas();
                }else{  
                        
                        
                        if(cb7 && kriptovahossz<kriptovakey.length-1){
                            vege=beolvas.readByte();
                            vege=(byte) ((byte) (vege)^kriptovakey[kriptovahossz]);
                            kriptovahossz++;
                            if(kriptovahossz>=kriptovakey.length-1)kriptovahossz=0;
                            
                            
                        }
                        //vege=beolvas.readByte();
                        if(a>kontenerkey.length-1)a=0;
                        vege=(byte) ((byte) (vege)^kontenerkey[a]);
                        
                        a++;
                        
                        doboz.writeByte(vege);
                        
                }
                    
                
            }
                  // if(jCheckBox6.isSelected())System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length-1);    //visszamásolom az eredeti kriptovakeyt
        
        } catch (IOException ex) {
            jTextArea1.append("\nKonténer IO hiba, fájlrendszer méret korlát vagy nincsen elég szabad hely\n"
                    + "A tétel nem lett a konténerhez hozzáadva.");
                    hozzaad=false;
           try {
               doboz.seek(fejlecpointer-1);
           } catch (IOException ex1) {
               Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
           }
           try {
               doboz.writeBoolean(true);
           } catch (IOException ex1) {
               Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
           }
            
           try {
               doboz.setLength(dobozmeret);
           } catch (IOException ex1) {
               Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
           }
           try {
               doboz.close();
               kontenerlezar();
               return;
           } catch (IOException ex1) {
               Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
           }
            kursor(0);
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            list1.add(kontfajlnev[szamol]);
            list1.select(list1.getItemCount()-1);
            
            
            beolvas.close();
            
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            
            //ha ujrahasznosított a hely akkor beírni utánna egy ugrató fejlécet
           
            
        }
         try {
            jLabel6.setText("Konténer mérete: "+String.valueOf(doboz.length()/1024/1024)+" Mb");
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        /*try {
            jTextArea1.append("\nKonténer Pointer : "+String.valueOf(doboz.getFilePointer()));
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }*/
             jLabel8.setText("Tömörítéssel felszabadítható hely:"+String.valueOf(felszabadithatohely/1024/1024)+" Mb");
        jLabel10.setText("Hely: "+String.valueOf(500));
        jLabel11.setText("Foglalt: "+String.valueOf(list1.getItemCount()));
        jLabel12.setText("Törölt: "+String.valueOf(tj));
        jLabel14.setText("Maradt: "+String.valueOf(500-(tj+list1.getItemCount())));
        szamol++;
        szabadhely=dobozszabadhely.getFreeSpace();
        list1.add("Szabad hely maradt a meghajtón: "+String.valueOf(szabadhely/1024/1024)+" MB");
        try {
            doboz.seek(fejlecpointer-1);
            doboz.writeBoolean(true);
           
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        list2.removeAll();
        if(voltfoglalt && !bedobott){
                      kny=0;
                      jPasswordField3.setText("");
                      jPasswordField3.setBackground(Color.green);
                      kontenerlezar();
                      voltfoglalt=false;
                      bedobott=false;
                  }
       vegez();
        
    }

    private void torlesrejelol() {
            tj=0;
            
            felszabadithatohely=0;
            if(listaboltorol)try { //ha töröltre jelölök
                list1.delItems(0, list1.getItemCount()-1);
                doboz.seek(fejlecpointer);
            } catch (IOException ex) {
                 jTextArea1.append("\nPointer állítási hiba");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            int ezttorolni=szamol;
            szamol=0;
        try {
            while(doboz.length()>doboz.getFilePointer() && szamol<500){
                //jTextArea1.append("."+String.valueOf(szamol));
                if(ezttorolni==szamol && listaboltorol){
                    doboz.writeBoolean(false);
                    kontflag[szamol]=false;
                    
                }else kontflag[szamol]=doboz.readBoolean();//ha vége a fájlnok itt kilép?
                
                
                for(int i=0;i<kontfilenevhossz;i++){filenevkiolvaso[i]=(char) doboz.readChar();
                    if(filenevkiolvaso[i]!=' ')filenevkiolvaso[i]=(char) (filenevkiolvaso[i]^kriptovakey[i]);
                }
                                
                kontfajlnev[szamol]=String.valueOf(filenevkiolvaso);//átírom a fájlnevet sztringbe
                if(kontflag[szamol]){
                
                    if(!jCheckBox3.isSelected())list1.add(kontfajlnev[szamol]);
                
                }//hozzáadom a fájlistához ha nincsen törlésre jelölve
                else {felszabadithato();}
                
                boolean alappin=false;
                byte kompointkod=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                if(alappin){
                         
                        konpoint[szamol]=doboz.readLong();
                    }
                    else{
                        
                        konpoint[szamol]=doboz.readLong()^kompointkod;
                    } 
                

                
                
                
                doboz.seek(doboz.getFilePointer()+konpoint[szamol]);// a következő olvasópozícióra állítom a fájlpointert
                
                              
                if(konpoint[szamol]>=doboz.length()){szamol++; return;}//elértem a konténerféjl végét az indexet növelem az új hozzáadásához
                
                 jLabel11.setText("Foglalt: "+String.valueOf(list1.getItemCount()));
                jLabel14.setText("Maradt: "+String.valueOf(500-(tj+list1.getItemCount())));
                szamol++;
                //ugrastnemszamol=szamol+ugrastnemszamol;
                
            }
        } catch (IOException ex) {
            
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
      //  throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void felszabadithato() {
        
        felszabadithatohely=felszabadithatohely+konpoint[szamol];tj++;
        jLabel8.setText("Tömörítéssel felszabadítható hely:"+String.valueOf(felszabadithatohely/1024/1024)+" Mb");
        jLabel10.setText("Hely: "+String.valueOf(500));
        jLabel11.setText("Foglalt: "+String.valueOf(list1.getItemCount()));
        jLabel12.setText("Törölt: "+String.valueOf(tj));
       jLabel14.setText("Maradt: "+String.valueOf(500-(tj+list1.getItemCount())));
        
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void kontenerbolkibont() {
        kezd();
         DataOutputStream kiir = null; 
        //szabadhely=dobozszabadhely.getFreeSpace(); 
                        try {
                                   try ( //munkakonyvtar szabad hely ellenörzése
                                           DataOutputStream hol = new DataOutputStream(new FileOutputStream("ez_mar_nincs_itt"))) {
                                       hol.writeBoolean(true);
                                   }
                       } catch (FileNotFoundException ex) {
                           Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                       } catch (IOException ex) {
                           Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                       }
                               File dir= new File ("ez_mar_nincs_itt");
                               
                                szabadhely=dir.getFreeSpace();
                               dir.delete();
                               

                 
            try { 
                
                doboz.seek(fejlecpointer);
            } catch (IOException ex) {
                 jTextArea1.append("\nPointer állítási hiba");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            int eztkibontani=szamol;
            szamol=0;
        try {
            while(doboz.length()>doboz.getFilePointer() && szamol<500){
                //jTextArea1.append("."+String.valueOf(szamol));
                if(eztkibontani==szamol){
                     kontflag[szamol]=doboz.readBoolean();
                     for(int i=0;i<kontfilenevhossz;i++){
                         filenevkiolvaso[i]=(char) doboz.readChar();
                        if(filenevkiolvaso[i]!=' ')filenevkiolvaso[i]=(char) (filenevkiolvaso[i]^kriptovakey[i]);}
                      kontfajlnev[szamol]=String.valueOf(filenevkiolvaso);//átírom a fájlnevet sztringbe
                      
                      boolean alappin=false;
                      byte kompointkod=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                     if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                    if(alappin){
                         
                        konpoint[szamol]=doboz.readLong();
                    }
                    else{
                        
                        konpoint[szamol]=doboz.readLong()^kompointkod;
                    } 
                
                    //meg kell vizsgálni van-e elég hely a kibontáshoz
                    if(szabadhely+5000000<konpoint[szamol]){
                        jTextArea1.append("\nA munkakönyvtár meghajtóján nincsen elegendő szabad hely a fájl kibontásához.");
                        kursor(0);
                        return;
                    }
                     
                    File kibont = new File("kontenerbol_kibontott");
                    kibont.mkdir();
                    
                    String kibontott;
                    int e=kontfajlnev[szamol].indexOf("_DATE_");
                    if(e<0){
                        jTextArea1.append("\nA kijelölt fájlhoz lehet, hogy nem ezt a mesterkulcsot használta.");
                               
                       kibontott=String.valueOf(generator()+".valami");
                    
                    }else kibontott=kontfajlnev[szamol].substring(0,e);
                    jTextArea1.append("\n"+kibontott);
                    
                        kiir=new DataOutputStream(new FileOutputStream("kontenerbol_kibontott\\"+kibontott));
                     
                     byte [] beolvasva= new byte[(jComboBox4.getSelectedIndex()+1)*20000];//kulcsnyit olvas be buff méret
                   
                    int a=0;
                    byte vege = 0;
                    long kiolvasasvegepoint=doboz.getFilePointer()+konpoint[szamol];
                    boolean cb7=jCheckBox7.isSelected();
                    int kriptovahossz=0;
                    
                    long kiolvasando=konpoint[szamol];
                    list2.removeAll();
                    long lepeskoz=kiolvasando/51L;
                    long lepes=51L;
                    
                    while(doboz.getFilePointer()<kiolvasasvegepoint){
                        kiolvasando=kiolvasasvegepoint-doboz.getFilePointer();
                            
                        if(kiolvasando<(lepeskoz*lepes)){
                        
                            list2.add("V");
                            list2.select(list2.getItemCount()-1);
                            lepes--;
                            if(lepes<1)list2.removeAll();
                        
                        }
                        
                       // if(jCheckBox6.isSelected())System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length-1);
                        if((kiolvasasvegepoint-doboz.getFilePointer())>(jComboBox4.getSelectedIndex()+1)*20000){
                           
                            doboz.read(beolvasva);
                            for(int i=0;i<kontenerkey.length-1;i++){
                                
                                 if(cb7 && kriptovahossz<(kriptovakey.length-1)){ //ha be van kapcsolva a kétkulcsos titkosítás
                                 beolvasva[i]=(byte) (beolvasva[i]^kriptovakey[kriptovahossz]);
                                 kriptovahossz++;
                                    if(i<kontenerkey.length-2)i++;
                                 if(kriptovahossz>=(kriptovakey.length-1))kriptovahossz=0;
                                }   
                                 beolvasva[i]=(byte) (beolvasva[i]^kontenerkey[i]);
                                
                               
                            }
                            kiir.write(beolvasva);
                           // if(jCheckBox6.isSelected())kulcsforgatas();
                        }else{  
                                
                                vege=doboz.readByte();
                                if(cb7 && kriptovahossz<kriptovakey.length-1){
                                    
                                    vege=(byte) ((byte) (vege)^kriptovakey[kriptovahossz]);
                                    kriptovahossz++;
                                    if(kriptovahossz>=kriptovakey.length-1)kriptovahossz=0;
                                   
                                    
                                }
                                
                                if(a>kontenerkey.length-1)a=0;
                                vege=(byte) ((byte) (vege)^kontenerkey[a]);
                                
                                a++;
                                
                                kiir.writeByte(vege);
                        }


                    } 
                    kiir.close();
                     //if(jCheckBox6.isSelected())System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length-1);    //visszamásolom az eredeti kriptovakeyt
                    jTextArea1.append("\nA kijelölt kibontva a munkakönyvtárba");
                    vegez();
                     jFileChooser1.rescanCurrentDirectory();
                    return;

                }else; //ha vége a fájlnok itt kilép?
                
                kontflag[szamol]=doboz.readBoolean();
                for(int i=0;i<kontfilenevhossz;i++)filenevkiolvaso[i]=(char) doboz.readChar();
                
                
                
                boolean alappin=false;// a következő tétel helyének kódolása pin beállítással
                byte kompointkod=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                if(alappin){
                         
                        konpoint[szamol]=doboz.readLong();
                }else{
                        
                        konpoint[szamol]=doboz.readLong()^kompointkod;
                    } 
                                             
               
                                 
                doboz.seek(doboz.getFilePointer()+konpoint[szamol]);// a következő olvasópozícióra állítom a fájlpointert
                
                              
                if(konpoint[szamol]>=doboz.length()){szamol++; return;}//elértem a konténerféjl végét az indexet növelem az új hozzáadásához
                
               
                szamol++;
                
            }
        } catch (IOException ex) {
            jTextArea1.append("\nValamilyen IO hiba. Ha a kibontandó fájl 4 GB-ot meghaladja, akkor ellenőrizze, hogy\n"
                    + "munkakönyvtár fájlrendszere támogatja e a nagy fájlokat. pl: Fat32 maximum 4GB..");
            try {
                kiir.close();
            } catch (IOException ex1) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
            }
            File csonkottorol= new File(kontfajlnev[szamol]);
            csonkottorol.delete();
               kursor(0);
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
                kiir.close();
            } catch (IOException ex1) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
            }
         jFileChooser1.rescanCurrentDirectory();
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void tomorites() {
        //helyméretet ellenőrizni kell
        
        
        try {
                                   try ( //munkakonyvtar szabad hely ellenörzése
                                           DataOutputStream hol = new DataOutputStream(new FileOutputStream("ez_mar_nincs_itt"))) {
                                       hol.writeBoolean(true);
                                   }
                       } catch (FileNotFoundException ex) {
                           Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                       } catch (IOException ex) {
                           Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                       }
                               File dir= new File ("ez_mar_nincs_itt");
                               
                                szabadhely=dir.getFreeSpace();
                               dir.delete();
        
        //szabadhely=dobozszabadhely.getFreeSpace(); 
        long kontmeret=dobozszabadhely.length();
        long ujkontmeret=kontmeret-felszabadithatohely;
        if(szabadhely+5000000<ujkontmeret){
            jTextArea1.append("\nAz tömörített konténer létrehozásához nincen elegendő szabad hely a meghajtón");
            kursor(0);
            return;
        }
        
        kezd();
        DataOutputStream tomoritett = null;
        String ujnev="kont.tom"+generator()+"_"+pinor;
        try {
            tomoritett=new DataOutputStream(new FileOutputStream(ujnev));
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (FileNotFoundException ex) {
            jTextArea1.append("\nNem sikerült a "+ujnev+" létrehozása");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            doboz.seek(0);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            byte [] fej;
            
            fej = new byte[(int)fejlecpointer];
            doboz.read(fej);
            tomoritett.write(fej);
                
                
            } catch (IOException ex) {
            jTextArea1.append("\nNem sikerült a fejléc  másolása");    
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //-----------------------------
         
        szamol=0;
        tj=0;   
            
        byte [] beolvasva=new byte [(jComboBox4.getSelectedIndex()+1)*20000];
        try {
           // jTextArea1.append("\nKonténerben : ");
            //jTextArea1.append("\nKonténer jelenlegi mérete : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
            jLabel6.setText("\nKonténer mérete : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
           // long fejlecpointer=doboz.getFilePointer();
            while(doboz.length()>doboz.getFilePointer() && szamol<500){
                //jTextArea1.append("."+String.valueOf(szamol));
                
                kontflag[szamol]=doboz.readBoolean();//ha igaz akkor a tétel átirandó
                
                
                
                for(int i=0;i<kontfilenevhossz;i++){
                    filenevkiolvaso[i]=(char) doboz.readChar();
                    //filenevkiolvaso[i]=(char) (filenevkiolvaso[i]^kriptovakey[i]);    
                }
                                
                  boolean alappin=false;
                      byte kompointkod=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                     if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappin=true;
                    if(alappin){
                         
                        konpoint[szamol]=doboz.readLong();
                    }
                    else{
                        
                        konpoint[szamol]=doboz.readLong()^kompointkod;
                    }
                                 
                
                
                long kiolvasasvege=doboz.getFilePointer()+konpoint[szamol];
                
                if(!kontflag[szamol]){doboz.seek(doboz.getFilePointer()+konpoint[szamol]);}// a következő olvasópozícióra állítom a fájlpointert
                else{
                    
                    tomoritett.writeBoolean(true);
                    for(int i=0;i<kontfilenevhossz;i++){tomoritett.writeChar((char)filenevkiolvaso[i]);filenevkiolvaso[i]=' ';}
                    
                    // a pin titkosítás ne vesszen el
                    
                    if(alappin){
                         
                       tomoritett.writeLong(konpoint[szamol]);
                    }
                    else{
                        
                        tomoritett.writeLong(konpoint[szamol]^kompointkod);
                    }
                    
                    
                    while(doboz.getFilePointer()<kiolvasasvege){


                        if(kiolvasasvege-doboz.getFilePointer()>(jComboBox4.getSelectedIndex()+1)*20000){
                            doboz.read(beolvasva);
                            
                            tomoritett.write(beolvasva);
                        }else{  
                                byte vege;
                                vege=doboz.readByte();
                               tomoritett.writeByte(vege);
                        }


                    }
                    
                }
                    
                
                
                
                
                
                if(konpoint[szamol]>=doboz.length()){szamol++; return;}//elértem a konténerféjl végét az indexet növelem az új hozzáadásához
                
               
                szamol++;
                //ugrastnemszamol=szamol+ugrastnemszamol;
            }
            doboz.seek(0);
            for(int ii=0;ii<(jComboBox4.getSelectedIndex()+1)*20000;ii++){doboz.writeByte(ii);}
             if(szamol==499){jTextArea1.append("\n\nA konténer megtelt, tömörítsen vagy hozzon létre újat");return;}//ennyi fért bele
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
            jTextArea1.append("\nIO Hiba. Az új fájl nem lett befejezve. Ellenőrizze, hogy a munkakönyvtár fájlrendszere nem \nkorlátozza-e a létrehozandó"
                    + "konténerfájl maximális méretét vagy, hogy a művelet közben nem fogyott el a szabad terüle?\n"
                    + "A tömörítendő konténer nem került megsemmisítésre. A probléma elhárítása után\n"
                    + "megismételhető a művelet.");
            
            try {
                tomoritett.close();
            } catch (IOException ex1) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
            }
            File csonkottorol = new File(ujnev);
            csonkottorol.delete();
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            //kontenerlezar();
            kursor(0);
            return;
        }
        
        //-------------------------------
       
       
        //dobozt lezárni törölni ás a tempet átnevezni a doboz nevére
        
        if(jCheckBox5.isSelected()){
            try {
                
                kny=0;
                jTextArea1.append("\nA konténer lezárva");
                jButton10.setEnabled(false);
                jButton12.setEnabled(false);
                jButton8.setEnabled(false);
                jButton9.setEnabled(false);
                
                jCheckBox5.setSelected(false);
                list1.delItems(0, list1.getItemCount()-1);
                jLabel8.setText("Tömörítéssel felszabadítható hely:                                ");
                jLabel7.setText("Neve:");
                jLabel10.setText("Szabad: ");
                jLabel11.setText("Foglalt: ");
                jLabel12.setText("Törölt: ");
                jLabel14.setText("Maradt: ");
                jTextArea1.setBackground(Color.black);
                jTextArea1.setForeground(Color.red);
                jTextArea1.append("\nKonténer új mérete : "+String.valueOf(tomoritett.size()/1024/1024)+" Mb");
                jLabel6.setText("Konténer mérete: konténer lezárva");
                jTextArea1.append("\nTömörítés vége. Újra kell nyitnia a konténerfájlt\nA Törölt állományoktól megtisztított konténer neve "+ujnev+"\nhelyezze a munkakönyvtárból az önnek megfelelő helyre");
                doboz.setLength(0);
                
                doboz.close();
                if(sornyitott)sor.close();
                File delet = new File(kontenernev);
                delet.delete();
                String sornev=kontenernev+".sor";
                File delet2 = new File(sornev);
                delet2.delete();
                
            } catch (IOException ex) {
                jTextArea1.append("\nA konténer már lezárva");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        else{jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.ORANGE);jTextArea1.setForeground(Color.black);}
        
        DataOutputStream sor = null;//létrehozom az uj sorfajlt
        try {
            sor=new DataOutputStream(new FileOutputStream(ujnev+".sor"));
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        long [] sorban=new long[sorbanalhatnak];
        for(int i=0;i<sorbanalhatnak;i++){
            sorban[i]=0;
        }
        try {
            for(int i=0;i<sorbanalhatnak;i++)sor.writeLong(sorban[i]);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            sor.close();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
      try {
            tomoritett.close();
        } catch (IOException ex) {
            jTextArea1.append("\nNem sikerült a kont fájl lezárása");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
      
      File regiidx = new File("idxold");
      
      
      
        
                jFileChooser1.setCurrentDirectory(regiidx);

                try {
                      gyorstorles();
                  } catch (IOException ex) {
                      Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
               
                    }
        
        
        
      regiidx.delete();
      munkakonyvtar();
      vegez();
       jFileChooser1.rescanCurrentDirectory();
    }

    private void button7() {
        
        if(!kkopen){jTextArea1.append("\n"+jPasswordField3.getText()+"\n Mesterkulcs választása nélkül nem fog menni a dolod... ");return;}
         if(jPasswordField3.getText().length()==0)return;
         if(jCheckBox5.isSelected()){//konténer kezelés ág
             
             if("rezet".equals(jPasswordField3.getText())){
             
                 try {
                     doboz.seek(fejlecpointer-1);
                 } catch (IOException ex) {
                     Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                 }
                 try {
                     doboz.writeBoolean(true);
                 } catch (IOException ex) {
                     Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                 }
                 return;
             }
             
                 if(kontenergeneralas){
                     jTextArea1.setBackground(Color.yellow);
                     jTextArea1.setForeground(Color.black);
                     kontenergeneralas();
                     kontenergeneralas=false;
                                      jTextArea1.setBackground(Color.black);
                 jTextArea1.setForeground(Color.yellow);
                 }//konténerg fugvény hívása
                    
                 else if(kontenernyitas){
                     
                    String crc=jPasswordField3.getText();
                    int crchossz=crc.length();
                    long crckod=0;
                    for(int a=0;a<crchossz;a++)crckod=(long)crckod+crc.charAt(a);
                    if(crckod!=mestercrc){
                        jTextArea1.append("\n"+jPasswordField3.getText()+"\n Nem megfelelő jelszó! ");
                         jTextArea1.setBackground(Color.red);
                         inditasproba++;
                          if(inditasproba>5)System.exit(0);
                        return;
                    }else{
                        jTextArea1.append("\n Jelszó ok! ");
                        inditasproba=0;
                        jTextArea1.setBackground(Color.black);
                        jTextArea1.setForeground(Color.yellow);
                        jPasswordField3.setBackground(Color.green);
                        kontenernev=jFileChooser1.getSelectedFile().getName();
                        kontenerhelye=jFileChooser1.getSelectedFile().getAbsolutePath();
                        sorbanall= new long[sorbanalhatnak];
                        
                        
                        
                        kpin1=jComboBox1.getSelectedIndex();
                        kpin2=jComboBox2.getSelectedIndex();
                        kpin3=jComboBox3.getSelectedIndex();
                        kpin4=jComboBox4.getSelectedIndex();
                        jTextArea1.append("\nA konténer megnyitva");
                        jButton10.setEnabled(true);
                        
                        jButton12.setEnabled(true);
                        jButton8.setEnabled(true);
                        jButton9.setEnabled(true);
                      //  jButton15.setEnabled(true);
                        
                        jComboBox1.setEnabled(false);
                        jComboBox2.setEnabled(false);
                        jComboBox3.setEnabled(false);
                        jComboBox4.setEnabled(false);
                                //jTextArea1.append(String.valueOf("\n"+Arrays.toString(kontenerkey))+String.valueOf(kontenerkey.length));
                        int reset=0;
                        for(int a=0;a<kontenerkey.length;a++){
                           
                        if(reset>crc.length())reset=0;
                        kontenerkey[a]=(byte) ((byte)kontenerkey[a]^(byte)crc.charAt(reset));
                        
                       
                        }
                        kontfejlecbeolvas();
                        if(!mesterkucshoztartozik){
                            jTextArea1.append("\nA konténer nem a mesterkulcshoz tartozik");
                            kontenerlezar();
                            mesterkucshoztartozik=true;
                            return;
                        }
                        jLabel8.setText("Tömörítéssel felszabadítható hely:"+String.valueOf(felszabadithatohely/1024/1024)+" Mb");
                        jLabel10.setText("Hely: "+String.valueOf(500));
                        jLabel11.setText("Foglalt: "+String.valueOf(list1.getItemCount()));
                        jLabel12.setText("Törölt: "+String.valueOf(tj));
                        jLabel14.setText("Maradt: "+String.valueOf(500-(tj+list1.getItemCount())));
                        kontenernyitas=false;
                    }   
                 
                 }
        
        }
         else if(indulasellenor) {
             
            
                String crc=jPasswordField3.getText();
                int crchossz=crc.length();
                long crckod=0;
                for(int a=0;a<crchossz;a++)crckod=(long)crckod+crc.charAt(a);
                if(crckod!=mestercrc){
                    inditasproba++;
                    jTextArea1.append("\n Nem megfelelő jelszó! Indításpróba:"+String.valueOf(inditasproba)+"\nVálassza ki a mesterkulcsot és adja meg a jelszót újra\n");
                    if(inditasproba>4){
                        jTextArea1.setBackground(Color.black);
                        jTextArea1.setForeground(Color.red);
                        jTextArea1.append("\n A következő hibás jelszó után a program megsemmisíti magát!");}
                    jButton1.setEnabled(false);
                     jButton2.setEnabled(false);
                      jButton3.setEnabled(false);
                    jCheckBox5.setEnabled(false);
                    jCheckBox4.setEnabled(false);
                    jCheckBox2.setEnabled(false);
                    //jButton3.setEnabled(false);
                    
                    if(inditasproba>5){
                        if(jCheckBox8.isSelected()){
                                try {
                                           try ( //önmegsemmisítés

                                                   DataOutputStream hol = new DataOutputStream(new FileOutputStream("kriptova.jar"))) {
                                               hol.writeBoolean(true);
                                               for(int i=0;i<3000;i++)hol.writeBytes("Önmegsemmisítés lefutott");
                                           }
                               } catch (FileNotFoundException ex) {
                                   Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                               } catch (IOException ex) {
                                   Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                               }
                        }  
                        
                       
                       System.exit(0); 
                    }
                    kkopen=false;
                    return;
                }
                //byte
                int reset=0;
                kriptovakeyor=new byte[kriptovakey.length];
                for(int a=0;a<kriptovakey.length;a++){
                    if(reset>crc.length())reset=0;
                    kriptovakey[a]=(byte) ((byte) ((byte)kriptovakey[a]^(byte)crc.charAt(reset))^jComboBox1.getSelectedIndex());
                    
                    if(jComboBox4.getSelectedIndex()>0){
                           kriptovakey[a]=(byte) (kriptovakey[a]^kriptovakey[jComboBox4.getSelectedIndex()]);//pin4 szoros csusztatás
                    }else ;
                    if(jComboBox3.getSelectedIndex()>0){
                            if(0<a-jComboBox3.getSelectedIndex())kriptovakey[a-jComboBox3.getSelectedIndex()]=(byte) (kriptovakey[a]^kriptovakey[a-jComboBox3.getSelectedIndex()]);//pin3 szoros csusztatás
                    }else if(a>3)kriptovakey[a]=(byte) (kriptovakey[a]^kriptovakey[a-4]);
                    
                }
                /* if(jCheckBox6.isSelected()){ 
                     if(jComboBox2.getSelectedIndex()>1)for(int i=0;i<jComboBox2.getSelectedIndex();i++)kulcsforgatas();//pin2 szörös forgatásra lezárt indítás
                     else kulcsforgatas();
                     jCheckBox6.setEnabled(false); 
                     forgatasbe=true;
                 }*/
                 if(jComboBox2.getSelectedIndex()>1)for(int i=0;i<jComboBox2.getSelectedIndex();i++){
                        if(i<2)kulcsforgatas();
                        if(i>1 && i<4)kulcsforgatas2();
                        if(i>3)kulcsforgatas3();
                 }//pin2 szörös forgatás
                     else;
                 
                System.arraycopy(kriptovakey, 0, kriptovakeyor, 0, kriptovakey.length); //kulcsmásolat megörzése
                String pinorvalto=String.valueOf(jComboBox1.getSelectedIndex())+String.valueOf(jComboBox2.getSelectedIndex())+String.valueOf(jComboBox3.getSelectedIndex())+String.valueOf(jComboBox4.getSelectedIndex());
                pinor= pinorvalto.hashCode();
                
                
                jLabel16.setText("MKey PIN:"+String.valueOf(jComboBox1.getSelectedIndex())+"."+String.valueOf(jComboBox2.getSelectedIndex())+"."
                        + ""+String.valueOf(jComboBox3.getSelectedIndex())+"."+String.valueOf(jComboBox4.getSelectedIndex())+"  HKód:"+String.valueOf(pinor));
                
                jLabel1.setText("          Válassza ki a fájlt");
            
            
            //itt ujra definiállom a logfájlokat ha van indítási pin beállítva + 40 000 lehetőség ugyanahhoz a mesterkulcshoz.
            
            if(pinor==1477632);
            else {//logtxt=String.valueOf(pinor);
                    //logtxt=logtxt+".kriptlog";
                    jTextArea1.append("\n Az indítási PIN az MKeyPIN jegyezze meg mert az így kódolt fájlok csak így dekódolhatók");
            //logfile ell ha kell létrehozni a munkakönyvtárba
                 /*   DataInputStream logellenor = null;
                    DataInputStream klogellenor = null;
                    try{

                            klogellenor=new DataInputStream(new FileInputStream("F"+logtxt));
                             logellenor=new DataInputStream(new FileInputStream(logtxt));
                    }catch(IOException ex){
                        DataOutputStream logklonozo = null;
                        DataOutputStream klogklonozo = null;

                        try {
                            klogklonozo=new DataOutputStream(new FileOutputStream("F"+logtxt));
                        } catch (FileNotFoundException ex1) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                        }
                        try {
                            logklonozo=new DataOutputStream(new FileOutputStream(logtxt));
                        } catch (FileNotFoundException ex1) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                        }
                        jTextArea1.append("\n\nAz adott pinkódhoz tartozó: "+logtxt+" és F"+logtxt+" fájlt is létrehoztam a\n munkakönyvtárba."
                                + "Az újonan létrehozandó konténerek csak ezzel az indítópinnel\nfognak működni."
                                + "A más pinnel létrehozott konténerek nem működnek!\n\n"
                                + "Megerősítéshez kattintson újra a Beír gombon.");
                        jTextArea1.setBackground(Color.blue);
                        jTextArea1.setForeground(Color.yellow);
                        
                        try {
                            logklonozo.close();
                        } catch (IOException ex1) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                        }
                        try {
                            klogklonozo.close();
                        } catch (IOException ex1) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                        }
                    }
                    try {
                        logellenor.close();
                    } catch (IOException ex) {
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    try {
                        klogellenor.close();
                    } catch (IOException ex) {
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    */
                }
                indulasellenor=false;
                jPasswordField3.setText("");
                jButton1.setEnabled(true);
                 jButton3.setEnabled(true);
                jCheckBox5.setEnabled(true);
                jButton2.setEnabled(true);
                jCheckBox4.setEnabled(true);
                jCheckBox2.setEnabled(true);
                jCheckBox9.setEnabled(true);
                //jButton3.setEnabled(true);
                jTextArea1.append("\nJelszó elfogadva.\n");
                kulcsnev=jFileChooser1.getSelectedFile().getAbsolutePath();
                jLabel15.setText("Key: "+jFileChooser1.getSelectedFile().getAbsolutePath());
                jComboBox1.setSelectedIndex(0);
                jComboBox2.setSelectedIndex(0);
                jComboBox3.setSelectedIndex(0);
                jComboBox4.setSelectedIndex(0);
                jFileChooser1.rescanCurrentDirectory();
                jPasswordField3.setBackground(Color.green);
                jTextArea1.setBackground(Color.black);
                        jTextArea1.setForeground(Color.yellow);
                inditasproba=0;
         }
         jPasswordField3.setText("");
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void kontenerfejleckestorles() {
        
        for(int i=0;i<konpoint.length-1;i++){
            szamol=i;
            //nyitasproba();
            konpoint[i]= 0;
            kontflag[i]=false;
            kontfajlnev[i]=" ";
            
        }
        jTextArea1.append("\nKontener adatok a memóriábol törölve");
        kursor(0);
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void kezd() {
                kursor(3);
                Calendar cal = Calendar.getInstance();
                kezdet = cal.getTimeInMillis();
                
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void vegez() {
                kursor(0);
                Calendar cal = Calendar.getInstance();
                veg = cal.getTimeInMillis();
                jTextArea1.setBackground(Color.black);
                jTextArea1.setForeground(Color.yellow);
                 jFileChooser1.rescanCurrentDirectory();
           jTextArea1.append("\nVégrehajtva: "+String.valueOf((veg-kezdet)/1000)+" sec");
        //repaint();
        //sleep(25);
           kezdet=0;veg=0;
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

   /* private void timestampellenorzes() {
            DataInputStream timestampell = null;
            try {
                timestampell=new DataInputStream(new FileInputStream("ts.key"));
                
            } catch (FileNotFoundException ex) {
                jTextArea1.append("\n Nem érzékeltem sikertelen belépési kisérletet");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                return;
            }
            long ellenor=0;
            try {
                ellenor=timestampell.readLong();
               
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            try {
                timestampell.close();
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            kezd();
            if((kezdet/1000)-(ellenor/1000)<300){System.exit(0);
            }else{
                File torol;
                torol= new File("ts.key");
                
                jTextArea1.append("\nSikertelen belépési kisérletet történt "+String.valueOf(((kezdet/1000)-(ellenor/1000))/60)+" perce");
                boolean delete = torol.delete();
            }
             
    //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }*/

 /*   private boolean nyitasproba() {
        
        try {// FIGYELEM minden a konténerben is megtatálható fájlt törörl a munkakönyvtárból
            DataOutputStream probanyitas=new DataOutputStream(new FileOutputStream(kontfajlnev[szamol]));
            probanyitas.close();
            File torol = new File(kontfajlnev[szamol]);
            torol.delete();
            
            return true;
            
//throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (FileNotFoundException ex) {
            
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        }
    }*/

    private void kontenerlezar() {
        if(jCheckBox5.isSelected()){
             try {
                 hiba=false;
                 kontenernev="false";
                 jLabel17.setText("");
                 jLabel1.setText("          Válassza ki a fájlt");
                 jLabel1.setForeground(Color.black);
                // doboz.seek(fejlecpointer-1);
                // doboz.writeBoolean(true);//ha az írásjelző beregadna
                 doboz.close();
                 if(sornyitott)sorbolki();
                 if(sornyitott)sor.close();
                 sornyitott=false;
                 kontener=false;
                 kontenergeneralas=false;
                 jCheckBox5.setSelected(false);
                 //jCheckBox6.setEnabled(true);
                 kontenerfejleckestorles();
                 kny=0;
                 jTextArea1.append("\nA konténer lezárva");
                 jButton10.setEnabled(false);
                
                 jButton12.setEnabled(false);
                 jButton8.setEnabled(false);
                 jButton9.setEnabled(false);
                 jButton15.setEnabled(false);
                 jCheckBox5.setSelected(false);
                 
                 jComboBox1.setEnabled(true);
                 jComboBox2.setEnabled(true);
                 jComboBox3.setEnabled(true);
                 jComboBox4.setEnabled(true);
                 
                 list1.delItems(0, list1.getItemCount()-1);
                 jLabel8.setText("Tömörítéssel felszabadítható hely:                                ");
                 jLabel7.setText("Neve:");
                 jLabel10.setText("Szabad: ");
                 jLabel11.setText("Foglalt: ");
                 jLabel14.setText("Maradt: ");
                 jLabel12.setText("Törölt: ");
                 jLabel6.setText("Konténer mérete: --");
                 jTextArea1.setBackground(Color.black);
                 jTextArea1.setForeground(Color.yellow);
                 kontenerkey=null;
             } catch (IOException ex) {
                 jTextArea1.append("\nA konténer már lezárva");
                 Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
             }
        }
        else{jTextArea1.append("\n Nincsen kiválasztva a konténer használat");jTextArea1.setBackground(Color.ORANGE);jTextArea1.setForeground(Color.black);}
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void visszaallit() {
        //Törlés bitek falsról trura
        kezd();
        list1.delItems(0, list1.getItemCount()-1);
        try {
            doboz.seek(fejlecpointer);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
         szamol=0;
        tj=0;   
        
             
        try {
           
            
            jLabel6.setText("\nKonténer mérete : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
           
            while(doboz.length()>doboz.getFilePointer() && szamol<500){
                
                doboz.writeBoolean(true);//itt állítom vissza
                kontflag[szamol]=true; 
                
                for(int i=0;i<kontfilenevhossz;i++){
                    filenevkiolvaso[i]=' ';
                    filenevkiolvaso[i]=(char) doboz.readChar();
                    if(filenevkiolvaso[i]!=' ')filenevkiolvaso[i]=(char) (filenevkiolvaso[i]^kriptovakey[i]);
                    
                }
                 //itt kellene ellenorizni, hogy csak azokat a tételeket listázza amik az aktuális mesterkulccsal lettek kódolva
                 
                 
                kontfajlnev[szamol]=String.valueOf(filenevkiolvaso);//átírom a fájlnevet sztringbe
                //if(!nyitasproba())mesterkucshoztartozik=false;
                list1.add(kontfajlnev[szamol]);//hozzáadom a fájlistához 
                 
                
                konpoint[szamol]=doboz.readLong();
                
                doboz.seek(doboz.getFilePointer()+konpoint[szamol]);// a következő olvasópozícióra állítom a fájlpointert
                
                             
                if(konpoint[szamol]>=doboz.length()){szamol++; return;}//elértem a konténerféjl végét az indexet növelem az új hozzáadásához
                
               
                szamol++;
                //ugrastnemszamol=szamol+ugrastnemszamol;
            }
             if(szamol==499){jTextArea1.append("\n\nA konténer megtelt, tömörítsen vagy hozzon létre újjat");return;}//ennyi fért bele
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
            jTextArea1.append("\nVége a konténer fájlnak");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        jLabel12.setText("Törölt: 0");
        jLabel11.setText("Foglalt: "+String.valueOf(szamol));
        jLabel14.setText("Maradt: "+String.valueOf(500-szamol));
        jLabel8.setText("Tömörítéssel felszabadítható hely:     0 Mb");
        vegez();
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

   

    private void kulcsforgatas() {
        
    byte [] seged;
    int max=kriptovakey.length-1;
    int min=0;
    seged=new byte [kriptovakey.length];
    for(int i=0;i<kriptovakey.length;i++){
              
        seged[max]=(byte) (kriptovakey[i]^kriptovakey.length-min);
        seged[min]=(byte) (kriptovakey[++i]^kriptovakey.length+max);
        max--;
        min++;
    }
        System.arraycopy(seged, 0, kriptovakey, 0, kriptovakey.length); //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    
 }
    private void kulcsforgatas2() {
        
    byte [] seged;
    int max=kriptovakey.length-1;
    int min=0;
    seged=new byte [kriptovakey.length];
    for(int i=0;i<kriptovakey.length;i++){
              
        seged[max]=(byte) (kriptovakey[i]+min);
        seged[min]=(byte) (kriptovakey[++i]-max);
        max--;
        min++;
    }
        System.arraycopy(seged, 0, kriptovakey, 0, kriptovakey.length); //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    
 }
    private void kulcsforgatas3() {
        
    byte [] seged;
    int max=kriptovakey.length-1;
    int min=0;
    seged=new byte [kriptovakey.length];
    for(int i=0;i<kriptovakey.length;i++){
              
        seged[max]=(byte) (kriptovakey[(kriptovakey.length-1)-i++]);
       
        seged[min]=(byte) (kriptovakey[(kriptovakey.length-1)-i]);
        max--;
        min++;
    }
        System.arraycopy(seged, 0, kriptovakey, 0, kriptovakey.length); //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    
 }

    private byte generator() {
        //véletlenszám generátor
        
        return (byte) ((byte) ((Math.random()*(Math.random()*500+1))+(Math.random()*100+1)));
        
        
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void gyorstorles() throws IOException {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
                    DataOutputStream labnyom = null;
                     File dir = null,dur,diror,ujnev;
                     dur=jFileChooser1.getCurrentDirectory();
                     
                    jFileChooser1.setCurrentDirectory(dur);
                    //dir=new File("kriptova_takarito");
                    String [] fajlok;
                    fajlok=dur.list();
                    int fajlokszama = fajlok.length;
                    for(int i=0;i<fajlokszama;i++){
                        jTextArea1.append("\n"+dur.getPath()+"\\"+fajlok[i]);
                        
                        
                        try{
                            labnyom=new DataOutputStream(new FileOutputStream(dur.getPath()+"\\"+fajlok[i]));
                            
                                try {
                                    for(int s=0;s<20;s++)labnyom.writeUTF("Kriptova_gyorstorles");
                                } catch (IOException ex) {
                                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                                }
                                jTextArea1.append("\nFelülírva...");
                            labnyom.close();
                            dir=new File(dur.getPath()+"\\"+fajlok[i]);
                            dir.setWritable(true);
                            dir.delete();
                                    
                        }catch(FileNotFoundException ex){
                            labnyom.close();
                            diror=jFileChooser1.getCurrentDirectory();
                            //jTextArea1.append("\nNem fájl: "+dur.getPath()+"\\"+fajlok[i]);
                            jFileChooser1.setCurrentDirectory(dir);
                            gyorstorles();
                            jFileChooser1.setCurrentDirectory(diror);
                        }
                       labnyom.close();
                       dir=new File(dur.getPath()+"\\"+fajlok[i]);
                       dir.setWritable(true);
                       dir.delete(); 
                       jFileChooser1.rescanCurrentDirectory();
                    }
    }

    private void gyorskodolas() throws FileNotFoundException, IOException {
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        RandomAccessFile olvas;
        RandomAccessFile ir;
                     File dir,dur,diror;
                     dur=jFileChooser1.getCurrentDirectory();
                     
                    jFileChooser1.setCurrentDirectory(dur);
                    //dir=new File("kriptova_takarito");
                    ir=new RandomAccessFile(dur.getAbsolutePath()+"\\"+String.valueOf(pinor),"rw");
                    ir.writeBoolean(true);
                    ir.close();
                    String [] fajlok;
                    fajlok=dur.list();
                    int fajlokszama = fajlok.length;
                    byte [] kodtomb;
                    //kodtomb = new byte[1024];
                    for(int i=0;i<fajlokszama;i++){
                        //jTextArea1.append("\n"+dur.getPath()+"\\"+fajlok[i]);
                        if(idxkodolas);
                        else {
                            list1.add(dur.getPath()+"\\"+fajlok[i]+" gyorskódolása...");
                            list1.select(list1.getItemCount()-1);
                        }
                        dir=new File(dur.getPath()+"\\"+fajlok[i]);
                        dir.setWritable(true);
                        int tombhossz=(int)dir.length();//ha intbe nem olvasható ki a nagysága miatt akkor -1 el tér vissza
                        if(tombhossz<0 || tombhossz>1000000000)tombhossz=1000000000; //1 gb-ig maximálom a kódolt részt egy fájlból
                        kodtomb = new byte[tombhossz];
                        try{
                            olvas = new RandomAccessFile((dur.getPath()+"\\"+fajlok[i]),"r");
                            try {
                                //if(olvas.length()>1024)
                                    olvas.read(kodtomb);
                            } catch (IOException ex) {
                                jTextArea1.append("\n1");
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                olvas.close();
                            } catch (IOException ex) {
                                jTextArea1.append("\n2");
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            
                            ir = new RandomAccessFile((dur.getPath()+"\\"+fajlok[i]),"rw");
                            int kkk=0;
                            //long hossz = 0;
                            //hossz=ir.length();
                            for(int a=0;a<tombhossz;a++){
                                if(kkk>kriptovakey.length-1)kkk=0;
                                kodtomb[a]=(byte) ((byte) ((byte) (kodtomb[a]^kriptovakey[kkk])^tombhossz)^a);
                                a++;
                                if(a<tombhossz)kodtomb[a]=(byte) ((byte) ((byte) (kodtomb[a]^tombhossz)^kkk)^kriptovakey[kkk]);
                                kkk++;
                            }
                            try {
                                //if(ir.length()>1024)
                                    ir.write(kodtomb);
                                
                            } catch (IOException ex) {
                                jTextArea1.append("\n3");
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                ir.close();
                            } catch (IOException ex) {
                                jTextArea1.append("\n4");
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }catch(FileNotFoundException ex){
                            diror=jFileChooser1.getCurrentDirectory();
                            //jTextArea1.append("\nNem fájl: "+dur.getPath()+"\\"+fajlok[i]);
                            jFileChooser1.setCurrentDirectory(dir);
                            gyorskodolas();
                            jFileChooser1.setCurrentDirectory(diror);
                        }
                                       
                }
    }

    private void kursor(int i) {
         
        Cursor curs = null;
        curs = new Cursor(i);
        NewApplication.super.setCursor(curs);
       
       jTextArea1.setCursor(curs);
      /*   list1.setCursor(curs);
        jButton1.setCursor(curs);
        jButton2.setCursor(curs);*/
       // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private boolean vanjelszo() {
        
        if((jPasswordField1.getText()==null || jPasswordField2.getText()==null) || (!jPasswordField2.getText().equals(jPasswordField1.getText())) || jPasswordField2.getText().length()<3){
            jTextArea1.append("\nHibásan adta meg a jelszót.");
            
            jPasswordField2.setText("");
            jPasswordField1.setText("");
            jPasswordField1.setBackground(Color.red);
            return false;
        }
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        pw=jPasswordField1.getText();
        jPasswordField2.setText("");
        jPasswordField1.setText("");
        return true;
    }

    private void rovkod(int i) {
        
        if(i==1){//kódoló ág
            byte [] uzenet;
            uzenet = new byte[jTextArea2.getText().length()];
            byte [] rokulcs;
            rokulcs = new byte [uzenet.length];
            DataOutputStream ki = null;
            kezd();
            String neve = "olvasatlan"+String.valueOf(kezdet);
            try {
                ki=new DataOutputStream(new FileOutputStream("olvasatlan"+String.valueOf(kezdet)));
            } catch (FileNotFoundException ex) {
                jTextArea1.append("\nFájl megnyitási hiba (rövid üzenetnél)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            int kki=0;
            byte s;
            String kodolando=jTextArea2.getText().trim();
            for(int a=0;a<uzenet.length;a++){
                rokulcs[a]=(byte) generator();
                uzenet[a]=' ';
                uzenet[a]=(byte) kodolando.charAt(a);
                s=uzenet[a];
                if(kki>kriptovakey.length-1)kki=0;
                uzenet[a]=(byte) ((byte) (s^rokulcs[a])^kriptovakey[kki]);
                kki++;
            }
            kezd();
            try {
                ki.writeInt(String.valueOf(pinor).hashCode());
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            try {
                ki.writeLong((kezdet)+(jComboBox7.getSelectedIndex()+1)*24*60*60*1000);
                
            } catch (IOException ex) {
                jTextArea1.append("\nFájl irási hiba (rövid üzenetnél)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            long ell=kezdet+(jComboBox7.getSelectedIndex()+1)*24*60*60*1000;
            String ells=String.valueOf(ell);
            ell=ells.hashCode();
            try {
                ki.writeLong(ell);
            } catch (IOException ex) {
                jTextArea1.append("\nFájl irási hiba (rövid üzenetnél)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            int pwell=pw.hashCode();
            try {
                ki.writeInt(pwell);
            } catch (IOException ex) {
                jTextArea1.append("\nFájl irási hiba (rövid üzenetnél)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            for(int a=0;a<uzenet.length;a++){
                try {
                    ki.writeByte(uzenet[a]);
                } catch (IOException ex) {
                    jTextArea1.append("\nFájl irási hiba (rövid üzenetnél)");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                try {
                    ki.writeByte(rokulcs[a]);
                } catch (IOException ex) {
                    jTextArea1.append("\nFájl irási hiba (rövid üzenetnél)");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            try {
                ki.close();
            } catch (IOException ex) {
                jTextArea1.append("\nFájl zárás hiba (rövid üzenetnél)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            jFileChooser1.rescanCurrentDirectory();
            jTextArea1.setText("");
            jTextArea1.append("\n A szöveges üzenet elkészült a munkakönyvtárba\n"
                    + "Neve: "+neve+"\n"
                    + "Húzhatja a levelező programba...");
            kursor(0);
        }else if(i==2){//dekód kiválasztó ág
            jTextArea1.append("\nKattintson duplán a dekódolandó szöveges üzeneten");
            return;
        }else if(i==3){//dekódoló ág
            jTextArea1.setText("");
             jTextArea1.append("\nDekódolás elkezdve");
             DataInputStream be = null;
            try {
                be=new DataInputStream(new FileInputStream(jFileChooser1.getSelectedFile()));
            } catch (FileNotFoundException ex) {
                jTextArea1.append("\nFájl nyitási hiba (rövid üzenet dekódolás)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            kezd();
            long idoell=0;
            int pin=0;
            try {
                pin=be.readInt();
            } catch (IOException ex) {
                jTextArea1.append("\nFájl olvasási hiba (rövid üzenet dekódolás)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            if(pin!=String.valueOf(pinor).hashCode()){
            jTextArea1.append("\nHkód eltérés, dekódolás így nem lehetséges");
                try {
                    be.close();
                } catch (IOException ex) {
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
                return;
            }
            
            try {
                idoell=be.readLong();
            } catch (IOException ex) {
                jTextArea1.append("\nFájl olvasási hiba (rövid üzenet dekódolás)");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            if(kezdet>idoell){
               jTextArea1.append("\nLejárt az üzenet érvényességi ideje");
                 try {
                     be.close();
                     ftorol();
                     return;
                 } catch (IOException ex) {
                     Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                 }
            } 
            String ells=String.valueOf(idoell);
            long ell=ells.hashCode();
            long ell2 = 0;
            try {
                ell2=be.readLong();
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            if(ell!=ell2){
                jTextArea1.append("\nManipulált az üzenet lejárati ideje");
                 try {
                     be.close();
                     ftorol();
                 } catch (IOException ex) {
                     Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                 }
                return;
            }
            int pwell=0;
            try {
                pwell=be.readInt();
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            pw=jPasswordField1.getText();
            int pwell2=pw.hashCode();
            if(pwell!=pwell2){
                jTextArea1.append("\n\nNem megfelelő a jelszó");
                 try {
                     be.close();
                 } catch (IOException ex) {
                     Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                 }
                 return;
            }
            byte [] gkod = null;
            byte [] uzenet = null;
            int maradek = 0;
            try {
                maradek = be.available()/2;
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            gkod=new byte[maradek];
            uzenet=new byte[maradek];
            try {
                int a=0;
                int kki=0;
                
                byte s;
                String ss = "";
                jTextArea2.setText("");
                for(a=0;a<maradek;a++){
                    uzenet[a]=' ';
                    uzenet[a]=be.readByte();
                    
                    gkod[a]=be.readByte();
                    if(kki>kriptovakey.length-1)kki=0;
                    s=uzenet[a];
                    uzenet[a]=(byte) ((byte) (s^gkod[a])^kriptovakey[kki]);
                    kki++;
                    ss=ss+String. valueOf((char)uzenet[a]);
                }
               
                jTextArea2.append(ss);
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            try {
                be.close();
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
             jFileChooser1.rescanCurrentDirectory();  
              jTextArea1.append("\nDekódolás befejezve");
            try {
                ftorol();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
            jPasswordField1.setBackground(Color.white);
            jPasswordField2.setBackground(Color.white);
            jPasswordField1.setText("");
            jPasswordField2.setText("");
             return;
        }else {
        }
       
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void gyorskereses() throws IOException {
         DataInputStream labnyom = null;
                     File dir,dur,diror;
                     dur=jFileChooser1.getCurrentDirectory();
                     
                    jFileChooser1.setCurrentDirectory(dur);
                    //dir=new File("kriptova_takarito");
                    String [] fajlok;
                    fajlok=dur.list();
                    int fajlokszama = fajlok.length;
                    for(int i=0;i<fajlokszama;i++){
                        jTextArea1.append("\n"+dur.getPath()+"\\"+fajlok[i]);
                        
                        dir=new File(dur.getPath()+"\\"+fajlok[i]);
                        
                        
                        try{
                            labnyom=new DataInputStream(new FileInputStream(dur.getPath()+"\\"+fajlok[i]));
                            osszdb++;
                            osszmeret=osszmeret+dir.length();
                            jFileChooser1.setSelectedFile(dir);
                            if(!"false".equals(kontenernev)&& hozzaad){
                                kontenerhezad();
                            }else if(jComboBox6.getSelectedIndex()==4){
                                seckod();
                            }  
                        }catch(FileNotFoundException ex){
                            diror=jFileChooser1.getCurrentDirectory();
                             jTextArea1.append("  >> almappa");
                            jFileChooser1.setCurrentDirectory(dir);
                            gyorskereses();
                            jFileChooser1.setCurrentDirectory(diror);
                        }
                        
                       
                   }
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void indexlog() {
        //irás előtt mindig készít egy indexlogot titkosítva
        
        
        DataOutputStream idx = null;
        kezd();
        File logdir = new File(kontenerhelye+"idxold");
        logdir.mkdir();
        jFileChooser1.setCurrentDirectory(logdir);
        idxkodolas=true;
        //gyorskodolas();
        try {
            jTextArea1.append(String.valueOf(kontenerhelye+"\\idxold\\"+kezdet)+"_"+kontenernev+".idxjav");
            idx=new DataOutputStream(new FileOutputStream(String.valueOf(kontenerhelye+"idxold\\"+kezdet)+"_"+kontenernev+".idxjav"));
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
       
         try { 
            doboz.seek(fejlecpointer); //fejlécelejére állok
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
            
            int kontfilenevhosszx=100;
            
         
          
        int szamolx=0;
        long idxeleje = 0;
        long dobozhossza = 0;
        try {
            idx.writeUTF(kontenernev);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            //tj=0;
            idxeleje = doboz.getFilePointer();//fejléc kezdete
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            dobozhossza=doboz.length();//módosítás előtti hossz
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            idx.writeLong(idxeleje);//fejléc kezdete
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            idx.writeLong(dobozhossza);//módosítás előtti hossz
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
             
        try {
            while(doboz.length()>doboz.getFilePointer() && szamolx<500){
               
               
                boolean x=doboz.readBoolean();
                idx.writeBoolean(x);//torolt vagy
                char xx;
                for(int i=0;i<kontfilenevhosszx;i++){
                    xx=doboz.readChar();
                     idx.writeChar(xx);//nev kodolva
                                        
                }
                long fhosszx=0;
                boolean alappinx=false;
                byte kompointkodx=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappinx=true;
                if(alappinx){
                        fhosszx =doboz.readLong();//fájlhossz
                        idx.writeLong(fhosszx);
                        //konpoint[szamol]=doboz.readLong();
                    }
                    else{
                        fhosszx =doboz.readLong()^kompointkodx;//fájlhossz
                        idx.writeLong(fhosszx);
                        //konpoint[szamol]=doboz.readLong()^kompointkodx;
                    } 
                
                
                  
                
                                        
                doboz.seek(doboz.getFilePointer()+fhosszx);// a következő olvasópozícióra állítom a fájlpointert
                
                             
               
                szamolx++;
                
            }
             if(szamol==499){jTextArea1.append("\n\nA konténer megtelt, tömörítsen vagy hozzon létre újjat");return;}//ennyi fért bele
             idx.close();
             
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
            try {
                /*  jTextArea1.setText(" ");
                jTextArea1.append("\nRoszz a pin?");
                kontenerlezar();*/
                idx.close();
            } catch (IOException ex1) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
            }
            
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        // gyorskodolas();
        idxkodolas=false;
        munkakonyvtar();
    }

    private void hibajavitas() {
        
        DataInputStream javitof = null;
        RandomAccessFile javitottf = null;
        try {
            javitof = new DataInputStream(new FileInputStream(javito));
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (FileNotFoundException ex) {
            jTextArea1.append("\n\nJavitó fájl megnyitási hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
       
        long ujeleje=0,ujvege=0;
            String nevelleneor = null;
        try {
            nevelleneor=javitof.readUTF();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        if(nevelleneor == null ? kontenernev != null : !nevelleneor.equals(kontenernev)){
            jTextArea1.append("\n\nA kiválasztott javítófájlban a kontener neve :"+nevelleneor+"\n"
                    + "Ha ezt a javítófájlt akarja használni akkor evezze át a konténert erre a névre");
            try {
                javitof.close();
                return;
            } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                return;
            }
        }
        
        try {
            ujeleje = javitof.readLong();
        } catch (IOException ex) {
             jTextArea1.append("\n\nJavitó fájl olvasási hiba:1");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            ujvege = javitof.readLong();
        } catch (IOException ex) {
             jTextArea1.append("\n\nJavitó fájl olvasási hiba:2");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
        
        
        try {
            javitottf = new RandomAccessFile(javitando,"rw");
        } catch (FileNotFoundException ex) {
             jTextArea1.append("\n\nKonténer fájl megnyitási hiba");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
        try {
            if(ujvege>javitottf.length()){
                jTextArea1.append("\n\nEz a javítófájl nem alkalmas a javításra,mert a konténer mérete\n"
                        + "kisebb mint amit a javítás eredményezne.\nVálaszzon korábbi dátumút vagy vizsgálja meg, hogy az adott konténerhez\n"
                        + "tartozik -e?");
                javitof.close();
                javitottf.close();
                return;
            }
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        try {
            javitottf.setLength(ujvege);
        } catch (IOException ex) {
             jTextArea1.append("\n\nKontenerfájl írás hiba:1");
             Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        //probaolvasas validitás ellenörzés
        
       
       
        //vissza állítom a javítási pozícióba
        try {
            javitottf.seek(ujeleje-1);
        } catch (IOException ex) {
            jTextArea1.append("\n\nKontenerfájl írás hiba:2");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
      
        
        try {
            javitottf.writeBoolean(true);
        } catch (IOException ex) {
            jTextArea1.append("\n\nKontenerfájl írás hiba:3");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        //egy új fájlt hozni létre amiben az ugrásméret hibákat is lehet javítani. ha valahol a közepén beletörölt valaki..
        
        int szamolx=0;
        try {
            while(javitottf.length()>javitottf.getFilePointer() && szamolx<500){
                
                
                boolean x=javitof.readBoolean();
                javitottf.writeBoolean(x);//torolt vagy
                char xx;
                for(int i=0;i<100;i++){
                    xx=javitof.readChar();
                    javitottf.writeChar(xx);//nev kodolva
                                        
                }
                long fhosszx=0;
                boolean alappinx=false;
                byte kompointkodx=(byte) ((jComboBox1.getSelectedIndex()+1)*(jComboBox2.getSelectedIndex()+2)*(jComboBox3.getSelectedIndex()+3)*(jComboBox4.getSelectedIndex()+4));
                if(jComboBox1.getSelectedIndex()==0 && jComboBox2.getSelectedIndex()==0 && jComboBox3.getSelectedIndex()==0 && jComboBox4.getSelectedIndex()==0)alappinx=true;
                if(alappinx){
                    fhosszx =javitof.readLong();//fájlhossz
                    javitottf.writeLong(fhosszx);
                    //konpoint[szamol]=doboz.readLong();
                }
                else{
                    fhosszx =javitof.readLong();//fájlhossz
                    javitottf.writeLong(fhosszx^kompointkodx);
                    //konpoint[szamol]=doboz.readLong()^kompointkodx;
                } 
                
                
                
                                        
                
                javitottf.seek(javitottf.getFilePointer()+fhosszx);// a következő olvasópozícióra állítom a fájlpointert
                
                
                
                szamolx++;
                
            }
        } catch (IOException ex) {
            jTextArea1.append("\n\nHiba a javítás közben.A javítás nem biztos, hogy sikerrel járt.");
            
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
                javitottf.close();
            } catch (IOException ex1) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
            }
            try {
                javitof.close();
            } catch (IOException ex1) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
            }
        
    }

    private void beleolvas(int i) {
        //i a lista index konpoint[i]
        
        
          kezd();
        
        try {
            doboz.seek(fejlecpointer);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        int keres=i;
        szamol=0;
        tj=0;   
        
             
        try {
           
            
            jLabel6.setText("\nKonténer mérete : "+String.valueOf(doboz.length()/1024/1024)+" Mb");
           
            while((doboz.length()>doboz.getFilePointer() && szamol<500)){
                
                doboz.readBoolean();//itt állítom vissza
                                
                for(int c=0;c<kontfilenevhossz;c++){
                    
                    filenevkiolvaso[c]=(char) doboz.readChar();
                  
                    
                }
                 //itt kellene ellenorizni, hogy csak azokat a tételeket listázza amik az aktuális mesterkulccsal lettek kódolva
                 
                               
                konpoint[szamol]=doboz.readLong();
                if(szamol==keres){
                    //itt kell kiolvasni a kódolt állomány fejlécét ha van ilyen
                    //két lépésben kell visszafejteni 1, konténerből , majd a titkosított állományból
                    
                    
                    if(jCheckBox2.isSelected()){
            
                            //kodnev = jFileChooser1.getSelectedFile().getName();

                            //int kodnevhossz = kodnev.length();
                            if(kulcsolt){ 

                            }else {
                                
                                kodoltneve="";
                                int kriptovahossz=0;
                                try {
                                    char [] nevkiolvaso = new char[100];
                                    for(int a=0;a<100;a++){
                                        nevkiolvaso[a]=' ';
                                        nevkiolvaso[a]=doboz.readChar();
                                        if(kriptovahossz>=(kriptovakey.length-1))kriptovahossz=0;
                                        nevkiolvaso[a]=(char) (char) (nevkiolvaso[a]^kriptovakey[kriptovahossz]);
                                       
                                        //if(i<kontenerkey.length-2)i++;
                                        
                                        nevkiolvaso[a]= (char) ((char) (nevkiolvaso[a]^kriptovakey[a])^pinor);
                                        kodoltneve=kodoltneve+String.valueOf((char)nevkiolvaso[a]);
                                        a++;
                                        nevkiolvaso[a]=' ';
                                        nevkiolvaso[a]=doboz.readChar();
                                        nevkiolvaso[a]=(char) (char) (nevkiolvaso[a]^kontenerkey[kriptovahossz]);
                                                      
                                        nevkiolvaso[a]= (char) ((char) (nevkiolvaso[a]^kriptovakey[a])^pinor);
                                        kodoltneve=kodoltneve+String.valueOf((char)nevkiolvaso[a]);
                                         kriptovahossz++;
                                    }
                                    
                                    int a=0;
                                    nevkiolvaso = new char[500];
                                    for(int x=0;x<500;x++){
                                        nevkiolvaso[x]=' ';
                                        nevkiolvaso[x]=doboz.readChar();
                                         if(kriptovahossz>=(kriptovakey.length-1))kriptovahossz=0;
                                         nevkiolvaso[x]=(char) (byte) (nevkiolvaso[x]^kriptovakey[kriptovahossz]);
                                      
                                        //if(i<kontenerkey.length-2)i++;
                                       
                                        
                                        nevkiolvaso[x]= (char) ((char) (nevkiolvaso[x]^kriptovakey[a])^pinor);
                                        a++;if(a>kriptovakey.length-1)a=0;
                                        x++;
                                        nevkiolvaso[x]=' ';
                                        nevkiolvaso[x]=doboz.readChar();
                                        nevkiolvaso[x]=(char) (byte) (nevkiolvaso[x]^kriptovakey[kriptovahossz]);
                                        kriptovahossz++;
                                        //if(i<kontenerkey.length-2)i++;
                                        
                                        nevkiolvaso[x]= (char) ((char) (nevkiolvaso[x]^kriptovakey[a])^pinor);
                                        a++;if(a>kriptovakey.length-1)a=0;
                                        
                                        jTextArea1.append(String.valueOf((char)nevkiolvaso[x]));
                                        if((x+1)%90==0)jTextArea1.append("\n");
                                    }

                                } catch (IOException ex) {
                                    jTextArea1.append("\nEz a fájl nem ezzel a mesterkulccsal, vagy pinbeállításokkal kódolt.");
                                    
                                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                                    return;
                                }
                                
                                
                                
                                 String mihez=kodoltneve;

                                int kodoltnevhossz=0;
                                kodoltnevhossz=kodoltneve.indexOf("_+_");
                                if(kodoltnevhossz<1){
                                    vegez();
                                    return;
                                }    
                                kodoltneve=kodoltneve.substring(0, kodoltnevhossz);
                                jTextArea1.append("\nFájl eredeti neve: "+kodoltneve);
                                int parametervege=mihez.indexOf("?");
                                int parametereleje=kodoltneve.length();
                                mihez=mihez.substring(parametereleje+3, parametervege);
                                jTextArea1.setForeground(Color.yellow);
                                jTextArea1.setBackground(Color.black);
                                mihez=mihez.replace("_","   ");
                                jTextArea1.append("\n\nFájl kódolás paraméterei, jelszóhossz, jelszó emlékeztető, pin 1-2-3-4:\n\t\t"+mihez);
                            }

                        }
                    
                    
                    
                }
                
                doboz.seek(doboz.getFilePointer()+konpoint[szamol]);// a következő olvasópozícióra állítom a fájlpointert
                
                             
                if(konpoint[szamol]>=doboz.length()){szamol++; return;}//elértem a konténerféjl végét az indexet növelem az új hozzáadásához
                
               
                szamol++;
                //ugrastnemszamol=szamol+ugrastnemszamol;
            }
             if(szamol==499){jTextArea1.append("\n\nA konténer megtelt, tömörítsen vagy hozzon létre újjat");return;}//ennyi fért bele
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
            jTextArea1.append("\nVége a konténer fájlnak");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        vegez();
        
//        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void seckod() throws IOException {
        
         
        jTextArea2.setEditable(true);
        jPasswordField1.setBackground(Color.white);
        jPasswordField2.setBackground(Color.white);
        if(kontener){
            jTextArea1.append("\nKonténer funkció bekapcsolva, a kódolt állományok a megnyitott\nkonténerbe kerülnek: "+kontenernev);
            jPasswordField1.setBackground(Color.white);
            jPasswordField2.setBackground(Color.white);
            //return;
            
        }
        
        
       
        if("".equals(pw)){
            jTextArea1.append("\n Nincsen megadva jelszó...");
            jTextArea1.setBackground(Color.black);
            jTextArea1.setForeground(Color.yellow);
             return;
        }
       
          //---------------------------pw szamsorrá alakítása
        char [] jsz;
        byte [] pwint;
        int pwhossz;
        
        pwhossz=pw.length();
        int regihossz=pwhossz;
        pwhossz=pwhossz*((jComboBox1.getSelectedIndex()+1)*20);//megnövelelem a beírt jelszót a 20*osára
        
        
        
       
        jsz = new char[pwhossz];
        pwint= new byte[pwhossz];
        //if(jCheckBox6.isSelected() && !forgatasbe)kulcsforgatas(); // ne keljen a kf-es állományok miatt ujraindítani a programot
        //jTextArea1.append("Jelszohossz: " + String.valueOf(pwhossz) + "\n");
        int valto=0;
        int kkh=0;
        for(int i=0;i<pwhossz;i++){
           if(regihossz+1>valto)valto=0;
           jsz[i]=(char) pw.charAt(valto);//stringből char tömbbe
           pwint[i]=(byte) getNumericValue(jsz[i]);//char tömbből int tömbbe
           if(kriptovakey.length-1>kkh)kkh=0;
           pwint[i]=(byte) ((byte) ((pwint[i]^kriptovakey[kkh])+i)^pwint[i]+pwhossz);
           //jTextArea1.append(String.valueOf(pwint[i])+".");
           //jsz[i]='.';
           valto++;
        }
       
        
        //pw="";
        //-----------------------pw átalakítás vége
        
        
        
        //adatgyujtes
        //jTextArea1.setText("");
        long tol;
         Calendar cal = Calendar.getInstance();
        tol = cal.getTimeInMillis();
        try {
            
            jTextArea1.append("Fájl eredeti helye: "+jFileChooser1.getSelectedFile().getPath()+"\n");
            kodoltneve=jFileChooser1.getSelectedFile().getName();
            
            kodolando=new DataInputStream(new FileInputStream(jFileChooser1.getSelectedFile().getPath()));
            
            jTextArea1.append("Fájl méret: "+String.valueOf(kodolando.available())+" bájt \n");
            
           
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
      
        File hossz= new File(jFileChooser1.getSelectedFile().getPath());
        bajt =hossz.length();
        
         try {

            //kimenet nyitása
            File kodolthelye = new File("kodolt");
            File dekodolthelye = new File("dekodolt");
            dekodolthelye.mkdir();
            kodolthelye.mkdir();
         if(jCheckBox2.isSelected()){//kodoltneve+=" - visszafejtése: "+cal.getTimeInMillis(); //ha visszfejt akkor már kész a neve a logbol();
            int eddig=kodoltneve.indexOf(".kriptova");
            kodoltneve=kodoltneve.substring(0,eddig);
        
        }   
            
            kodolt = (!jCheckBox2.isSelected()) ? new DataOutputStream(new FileOutputStream("kodolt\\"+String.valueOf(kodoltneve+".kriptova"))) : new DataOutputStream(new FileOutputStream("dekodolt\\"+kodoltneve));
            jTextArea1.append("\n Kódolandó fájl megnyitva");
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            jTextArea1.append("\n Kódolandó fájl megnyitása sikertelen");
        }
        
        if(jCheckBox2.isSelected()){//kodoltneve+=" - visszafejtése: "+cal.getTimeInMillis(); //ha visszfejt akkor már kész a neve a logbol();
            
        
        }else {
            //kodoltneve=String.valueOf(tol)+"^^"+kodoltneve; 
            int kodoltnevehossz=100;//=kodoltneve.length();
            char [] kodoltnevebyte = new char[kodoltnevehossz];
            for(int i=0;i<kodoltnevehossz;i++){
                kodoltnevebyte[i]=' ';
                if(i<kodoltneve.length()){
                    kodoltnevebyte[i]=kodoltneve.charAt(i);
                    kodoltnevebyte[i]=(char) ((char) (kodoltnevebyte[i]^kriptovakey[i])^pinor);
                }
                else kodoltnevebyte[i]=(char) ((char)(kodoltnevebyte[i]^kriptovakey[i])^pinor);
                try {
                    kodolt.writeChar(kodoltnevebyte[i]);
                } catch (IOException ex) {
                    jTextArea1.append("\nFejléc: írás hiba KFI1");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            jTextArea2.setText("");
            jTextArea2.append(jta2);
            int a=0;
            kodoltnevebyte = new char[500];
            if(jCheckBox6.isSelected()){
                jTextArea2.append("\nKulcsforgatással kódolt PIN: "+String.valueOf(jComboBox1.getSelectedIndex())+String.valueOf(jComboBox2.getSelectedIndex())
                +String.valueOf(jComboBox3.getSelectedIndex())+String.valueOf(jComboBox4.getSelectedIndex()));
            }else jTextArea2.append("\nNem kulcsforgatással kódolt PIN: "+String.valueOf(jComboBox1.getSelectedIndex())+String.valueOf(jComboBox2.getSelectedIndex())
                +String.valueOf(jComboBox3.getSelectedIndex())+String.valueOf(jComboBox4.getSelectedIndex()));
             for(int i=0;i<500;i++){
                kodoltnevebyte[i]=' ';
                if(i<jTextArea2.getText().length()){
                    kodoltnevebyte[i]=jTextArea2.getText().charAt(i);
                    kodoltnevebyte[i]=(char) ((char) (kodoltnevebyte[i]^kriptovakey[a])^pinor);
                }
                else kodoltnevebyte[i]=(char) ((char)(kodoltnevebyte[i]^kriptovakey[a])^pinor);
                a++;if(a>kriptovakey.length-1)a=0;
                try {
                    kodolt.writeChar(kodoltnevebyte[i]);
                } catch (IOException ex) {
                    jTextArea1.append("\nFejléc: írás hiba KFI1");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
             //jTextArea2.setText("");
            try {
                kodolt.writeLong(pinor);
            } catch (IOException ex) {
                jTextArea1.append("\nFejléc: írás hiba KFI2");
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        byte  [] ujkulcs;
        //mikro fajlokhoz
        if (bajt<20000)ujkulcs = pwint; //kis fájlnál a pw hossza a kulcs hossza
        else ujkulcs =new byte[(jComboBox4.getSelectedIndex()+1)*20000];
        
        ujkulcshossz=ujkulcs.length;
        if(bajt<ujkulcshossz){ //ha túl nagy a buffer leveszem a fájl méret alá
            ujkulcshossz=20000;
            ujkulcs =new byte[ujkulcshossz]; //ujradefiniálom a kulcstömb méretét
        }
        
        //ide kerülhetne egy kulcsérték generálás a pw hosszabbítására és annak a visszafejtéskori kiolvasása 
        if(jCheckBox2.isSelected() && bajt>ujkulcshossz){
                //visszaolvasni a kulcsértéket a kodolandóbol 
                              
                   try {
                       kodolando.read(ujkulcs);
                                
                    } catch (IOException ex) {
                        jTextArea1.append("\n Kulcs olvasási hiba");    
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                                 
            
                
        }
        else if(!jCheckBox2.isSelected() && bajt>ujkulcshossz) {
                //új kulcsértéket generálni
                              
                
             
                for(int i=0;i<ujkulcshossz;i++){
                    
                    ujkulcs[i]=generator();
                   
                }
               
                try {
                    kodolt.write(ujkulcs);
                } catch (IOException ex) {
                    jTextArea1.append("ujkulcs írás hiba");
                    Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                }
             
            
        }
        
        try {
            //pw és pw hossz;
            int kkl=kriptovakey.length;
            int kkh2=0;//mesterkulcsindex
            int merce2=jComboBox2.getSelectedIndex();
            int pin3=jComboBox3.getSelectedIndex()+1;
            //byte [] tobbkulcs;
            //tobbkulcs=new byte[ujkulcshossz];
            int kelujkulcs=0;
            byte [] olvasint = new byte[ujkulcshossz];
            byte [] atirint = new byte[ujkulcshossz];
                
            int a;
            byte [] seged;
            seged=new byte [pwhossz];
               
            long vanmeg;
            vanmeg = 0;
            long lepesszam=51L;
            long mikorlepni=bajt/51L;
            long vanbajt=bajt;
            while(kodolando.available()>0){
                
                if(vanbajt/mikorlepni==lepesszam){
                        
                            list2.add("V");
                            list2.select(list2.getItemCount()-1);
                           lepesszam--;
                           if(lepesszam<0)list2.removeAll();
                }
               vanbajt=vanbajt-ujkulcshossz;
                if(kodolando.available()>ujkulcshossz){
                    
                    //pót segégkulcsok beépített kulcsok
                    if(!jCheckBox2.isSelected()){
                        if(kelujkulcs>pin3*100){
                            for(int l=0;l<ujkulcshossz;l++){
                                ujkulcs[l]=generator();
                                kodolt.writeByte(ujkulcs[l]);
                            }
                            kelujkulcs=0;
                        }
                    
                    }else{
                        if(kelujkulcs>pin3*100){
                            for(int l=0;l<ujkulcshossz;l++){
                                
                                ujkulcs[l]=kodolando.readByte();
                            }
                            kelujkulcs=0;
                        }
                    }
                    vanmeg=kodolando.available();
                    if(!jCheckBox6.isSelected()){
                      
                                int max=pwhossz-1;
                                int min=0;

                                for(int i=0;i<pwhossz;i++){

                                    seged[max]=(byte) (pwint[i]^vanmeg);
                                    seged[min]=(byte) (pwint[++i]^vanmeg);
                                    max--;
                                    min++;
                                }
                        System.arraycopy(pwint, 0, seged, 0, pwhossz);
                    }
                        kodolando.read(olvasint); //jelszohosszal pufferelt ág
                        kelujkulcs++;
                       
                        
                        int max1=ujkulcshossz-1;
                        int min1=0;
                        seged=new byte[ujkulcshossz]; 
                        
                        for(a=0;a<ujkulcshossz;a++){
                             int merce=0;
                             int beirt=0;
                          
                             
                           
                                 do{//kódolásmélység
                                     
                                     if(beirt>pwhossz-1)beirt=0;
                                     if(kkh2>kkl-1){
                                         
                                         kkh2=0;
                                         
                                         
                                     }
                                     if(jCheckBox6.isSelected()){
                                        
                                         
                                         if(a%2==0)atirint[a]=(byte) ((byte)  ~olvasint[a]^kriptovakey[kkh2]+ujkulcs[a]);
                                         else atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^kriptovakey[kkh2]);
                                         
                                        
                                                
                                     }
                                     else {
                                         
                                       if(a%2==0)atirint[a]=(byte) ((byte)  ~olvasint[a]^kriptovakey[kkh2]+ujkulcs[a]);
                                         else atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^kriptovakey[kkh2]);
                                         
                                         
                                         
                                     }
                                     beirt++;
                                     merce++;
                                     kkh2++;
                                     
                                 }while(merce<merce2);
                                 
                                 if(jCheckBox6.isSelected()){
                                                                     
                                     if(((a)%kkh2+13)==0)kulcsforgatas3();
                                     else  if(((a)%beirt+7)==0)kulcsforgatas2();
                                     else if(((a)%kelujkulcs*2)==0)kulcsforgatas();
                                 }
                                 if(jCheckBox2.isSelected())ujkulcs[a]=(byte) (olvasint[a]^pwint[beirt]);//beirt és felhosszabbított pw-wel ráxorzok
                                 else ujkulcs[a]=(byte) (atirint[a]^pwint[beirt]);
                             
                               
                         
                             if(jCheckBox6.isSelected()){    //generált kulcs forgatása
                                    seged[max1]=(byte) (ujkulcs[a]);
                                    if(a<ujkulcshossz-2)seged[min1]=(byte) (ujkulcs[a+1]);
                                    else seged[min1]=ujkulcs[a-1];
                                    max1--;
                                    min1++;
                            }
                                    
                        }
                         
                         if(jCheckBox6.isSelected())System.arraycopy(ujkulcs, 0, seged, 0, ujkulcshossz);
                         kodolt.write(atirint);
                    
                }
                else { //bájtonkénti ág ha már kevés van hátra puffernél kisebb maradék
                        kkh2=0;//mesterkulcsindex
                        kkl=kriptovakey.length;
                        for(a=0;a<ujkulcshossz;a++){
                            int beirt=0;
                            try{
                                olvasint[a]=kodolando.readByte();
                            } catch (IOException ex){
                                 jTextArea1.append("\n A fájl olvasása befejeződött");
                                a=pwhossz;
                                 break;
                               //Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                               
                            }
                            int merce=0;
                            do{//kódolásmélység
                                if(beirt>pwhossz-1)beirt=0;
                                if(kkh2>kkl-1){
                                      
                                      kkh2=0;
                                      if(jCheckBox6.isSelected()){
                                          kulcsforgatas();
                                          
                                      }
                                  }

                               if(jCheckBox6.isSelected()) atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^kriptovakey[kkh2]);
                                  else {
                                      atirint[a]=(byte) ((byte) (olvasint[a]^ujkulcs[a])^pwint[beirt]);
                                     
                                      atirint[a]=(byte) ((byte) ((byte) (atirint[a])^kriptovakey[kkh2])^ujkulcs[a]);
                                   }        
                                     beirt++;
                                    merce++;
                                    kkh2++;
                                
                            }while(merce<merce2);
                        //kimenet írása
                        try{
                            kodolt.writeByte(atirint[a]);
                        } catch (IOException ex) {
                            jTextArea1.append("\n "+kodoltneve+" fájl írás hiba");
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
            
                } 
                            
            }
            System.arraycopy(kriptovakeyor, 0, kriptovakey, 0, kriptovakey.length); //jLabel4.setText("Fajl:" +String.valueOf(jsz));
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
       
        //if(!jCheckBox5.isSelected()){
            list1.add("átkódolva >>  "+kodoltneve);
            list1.select(list1.getItemCount()-1);
                 // }else{
        //itt kell átadni a nyitott konténernek kontenerhezad()
           /* File atadom=new File("\\kodolt\\"+kodoltneve);
            jFileChooser1.setSelectedFile(atadom.getAbsoluteFile());
            kontenerhezad();
            atadom.delete();*/
       // }
        
        if(jCheckBox1.isSelected()){
            try {
                ftorol();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        //if(Inputnyitott)streamclos1();
        //if(Outputnyitott)streamclos2();
        kodolt.close();
        kodolando.close();
        jTextArea1.setBackground(Color.green);
        jTextArea1.setForeground(Color.black);
        jCheckBox2.setEnabled(true);
        cal = Calendar.getInstance();
        long ig = cal.getTimeInMillis();
        
        long eredm=ig-tol;
        jTextArea1.append("\nBefejezve : "+cal.getTime());
        jTextArea1.append("\nVégrehajtási idő sec : "+String.valueOf(eredm/1000));
        //double speed;
        double mb = (bajt/1024/1024);
        jTextArea1.append("\nEredmény : "+String.valueOf(mb/(eredm/1000))+" MB/sec");
      /*  if(jCheckBox3.isSelected() && !jCheckBox2.isSelected()){
            logkodolas();
            log();
            logkodolas();
        }*/
        jLabel1.setForeground(Color.black);
        jLabel1.setText("          Válassza ki a fájlt");
//        jLabel2.setText("Jelszó %");
        //jCheckBox2.setSelected(true);
        jButton1.setText("Kódolás");
        jComboBox4.setEnabled(true);
        jComboBox3.setEnabled(true);
        jComboBox2.setEnabled(true);
        jComboBox1.setEnabled(true);
         jFileChooser1.rescanCurrentDirectory();
        
         kursor(0);
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void bedobott() throws IOException {
        
         if("false".equals(kontenernev))jTextArea1.append("\nNincs megnyitott konténer.\n ");
         jTextArea1.append("\nMappában található:\n ");
         bedobott=true;
        DataInputStream labnyom = null;
                     File dir,dur,diror,torol;
                     if(csakegyszer)dur=new File(jTextPane1.getText());
                     else dur=new File(jFileChooser1.getCurrentDirectory().getPath()+"\\kodolt");
                     
                /*     if(!hozzaad){
                         if(ki)sorbolki(); // a kódolás alatt ne fogja a konténert írók sorát <<-A bedobóablaknál lett lekezelve
                         ki=false;
                     }*/
                    
                     jTextPane1.setText("");
                     jTextArea1.setText("");
                    jFileChooser1.setCurrentDirectory(dur);
                    jTextArea1.append(dur.getPath());
                    String [] fajlok;
                    fajlok=dur.list();
                    int fajlokszama = fajlok.length;
                    osszdb=0;osszmeret=0;kimaradtdb=0;kimaradmeret=0;
                    for(int i=0;i<fajlokszama;i++){
                        jTextArea1.append("\n"+dur.getPath()+"\\"+fajlok[i]);
                        
                        dir=new File(dur.getPath()+"\\"+fajlok[i]);
                        
                        try{
                            labnyom=new DataInputStream(new FileInputStream(dur.getPath()+"\\"+fajlok[i]));
                            osszdb++;
                            osszmeret=osszmeret+dir.length();
                            jFileChooser1.setSelectedFile(dir);
                            if(!"false".equals(kontenernev) && hozzaad){ 
                                kontenerhezad();
                            }
                            else if(jComboBox6.getSelectedIndex()==4){
                                //tömeges kódolás ága
                                seckod();
                            
                            }
                                
                        }catch(FileNotFoundException ex){
                            diror=jFileChooser1.getCurrentDirectory();
                            jTextArea1.append("  >> almappa");
                            jFileChooser1.setCurrentDirectory(dir);
                            try {
                                gyorskereses();
                            } catch (IOException ex1) {
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex1);
                            }
                            jFileChooser1.setCurrentDirectory(diror);
                        } catch (IOException ex) {
                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            }
                        
                        
                   }
              
                    
                try {
                    try ( //munkakonyvtar beallitas
                            DataOutputStream hol = new DataOutputStream(new FileOutputStream("mk"))) {
                        hol.writeBoolean(true);
                        hol.close();
                    }
                    } catch (FileNotFoundException ex) {
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    } catch (IOException ex) {
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                File mk = new File ("mk");
                 jFileChooser1.setCurrentDirectory(mk);
                 mk.delete();
               
               
                 jFileChooser1.rescanCurrentDirectory();    
                 jTextArea1.append("\n a mappában összesen: "+String.valueOf(osszdb)+" fájl van");
                 jTextArea1.append("\n a mappában összesen: "+String.valueOf(osszmeret/1024/1024)+" MB adat van");
                 jTextArea1.append("\nkimaradt összesen: "+String.valueOf(kimaradtdb)+" fájl");
                 jTextArea1.append("\nkimaradt összesen: "+String.valueOf(kimaradmeret/1024/1024)+" MB adat");
                jComboBox1.setSelectedIndex(0);
                jComboBox2.setSelectedIndex(0);
                jComboBox3.setSelectedIndex(0);
                jComboBox4.setSelectedIndex(0);
               
                 
                     list1.removeAll();
                 try {
                        
                        doboz.seek(fejlecpointer);
                        kontfejlecbeolvas();
                        } catch (IOException ex) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
                 if(jCheckBox5.isSelected() && jComboBox6.getSelectedIndex()==4){
                     //
                     jComboBox6.setSelectedIndex(0);
                     labnyom.close();
                     csakegyszer=false;
                     hozzaad=true;
                     if(sorbaall());
                        else{
                            hozzaad=false;
                            //sorbolki();
                            kontenerlezar();
                            System.exit(0);
                            return;
                        }
                     bedobott();
                     try {
                    try ( //munkakonyvtar beallitas
                            DataOutputStream hol = new DataOutputStream(new FileOutputStream("kodolt\\mkk"))) {
                        hol.writeBoolean(true);
                        hol.close();
                    }
                    } catch (FileNotFoundException ex) {
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    } catch (IOException ex) {
                        Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    mk = new File ("kodolt\\mkk");
                    jFileChooser1.setCurrentDirectory(mk);
                    mk.delete();
                    
               
                    jFileChooser1.rescanCurrentDirectory();
                     
                     gyorstorles();
                 
                 }
                  jPasswordField1.setText("");
                  jPasswordField2.setText("");
                  jComboBox6.setSelectedIndex(0); 
                  csakegyszer=true;
                  hozzaad=false;
                  if(voltfoglalt){
                      kny=0;
                      jPasswordField3.setText("");
                      jPasswordField3.setBackground(Color.green);
                      kontenerlezar();
                      voltfoglalt=false;
                      bedobott=false;
                  }
        //labnyom.close();
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void munkakonyvtar() {
         try {
                    try ( //munkakonyvtar beallitas
                            DataOutputStream hol = new DataOutputStream(new FileOutputStream("ez_mar_nincs_itt"))) {
                        hol.writeBoolean(true);
                    }
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
                File dir= new File ("ez_mar_nincs_itt");
                 jFileChooser1.setCurrentDirectory(dir);
               
                dir.delete();
                 jFileChooser1.rescanCurrentDirectory();
//throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private boolean sorbanall() {
        
        try {
            
            
            sor=new RandomAccessFile(kontenerhelye+".sor","rw");
            sornyitott=true;
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (FileNotFoundException ex) {
            jTextArea1.append("\nNem megnyitható a sorkezelő fájl,\n nyomja meg a mégse gombot és próbálkozzon újra.");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            for(int i=0;i<sorbanalhatnak;i++)sorbanall[i]=sor.readLong();
        } catch (IOException ex) {
            jTextArea1.append("\nNem olvasható a sorkezelő fájl,\n nyomja meg a mégse gombot és próbálkozzon újra.");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        int mennyien=0;
        for(int i=0;i<sorbanalhatnak;i++){
                if(sorbanall[i]!=0)mennyien++;
        }
        if(mennyien==sorbanalhatnak){
            jTextArea1.append("\nMinden hely foglalt az írási sorban\nkésőbb próbálkozzon újra.");
            
            return false;
        }else{
            jTextArea1.append("\nAz írási sorban várakoznak :"+String.valueOf(mennyien));
            
        }
        return true;
    }

    private boolean sorbaall() throws IOException {
        
        try {
            sor.seek(0);
            
            //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        } catch (IOException ex) {
           
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        }
        try {
            for(int i=0;i<sorbanalhatnak;i++)sorbanall[i]=sor.readLong();
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        int mennyien=0;
        long max=0;
       
        //ki a legnagyobb az utolsó a sorban
        for(int a=0;a<sorbanalhatnak;a++){
                
                if(max<sorbanall[a]){
                    max=sorbanall[a];
                    
                 }
                               
        }
        //én leszek a legnagyobb sorszámmal belépő
        long kulonbozet=0;
        for(int i=0;i<sorbanalhatnak;i++){
                
                if(sorbanall[i]==0){
                    kezd();
                    
                    if(kezdet<max){
                        kulonbozet=(max-kezdet)-60000; //mindenki idejét realizálom az enyémhez, hogy ne lehessen az óra miatt túl sokat várni.
                        jTextArea1.append("\nValakinek nem jól jár az órája...");
                        doboz.seek(0);
                    }
                    sorbanall[i]=kezdet;
                    enyem = i; //ez az én indexem a sorban az itt szereplő értékhez viszonyítom, hogy kik vannak előttem
                    break;
                }
                mennyien++;
        }
        boolean vissza=false;
        if(mennyien==sorbanalhatnak){
             jTextArea1.append("\nMinden hely elfogyott az írási sorban\nkésőbb próbálkozzon újra.");
             return vissza;
        }
        try {
            sor.seek(0);
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        long [] ellenorzo;
        ellenorzo=new long[sorbanalhatnak];
        try {
            for(int i=0;i<sorbanalhatnak;i++){
                sorbanall[i]=sorbanall[i]-kulonbozet;
                sor.writeLong(sorbanall[i]);
                ellenorzo[i]=sorbanall[i];
                regiek[i]=sorbanall[i];
            }
        } catch (IOException ex) {
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
        //megvizsgálni kik vannak előttem és őket figyelni, hogy végeztek e már a várakozási idő letelte előtt, valamint
        int kellvarni=0; 
        for(int i=0;i<sorbanalhatnak;i++){
               
               if(sorbanall[i]!=0 && sorbanall[i]<sorbanall[enyem])kellvarni++;//ellenörizni, hogy elfogytak e már az előttem lévők         ellenorzo[i]=sorbanall[i]; 
                                    
         }
         if(kellvarni>0)
          { 
        
        
                        long varakozik=0;
                        kezd();
                        long k=kezdet;
                        switch (jComboBox8.getSelectedIndex()) {
                            case 0:
                                varakozik=1000*60;
                                break;
                            case 1:
                                varakozik=1000*60*3;
                                break;
                            case 2:
                                varakozik=1000*60*5;
                                break;
                            case 3:
                                varakozik=1000*60*10;
                                break;
                            case 4:
                                varakozik=1000*60*30;
                                break;
                            case 5:
                                varakozik=1000*60*60;
                                break;
                            case 6:
                                varakozik=1000*60*120;
                                break;
                            case 7:
                                varakozik=1000*60*180;
                                break;
                            default:
                                break;
                        }
                        list2.removeAll();
                        list2.setBackground(Color.red);
                        list2.add("S");
                        list2.add("0");
                        list2.add("R");
                        list2.add("B");
                        list2.add("A");
                        list2.add("N");
                        list2.add("");
                        list2.add(String.valueOf(kellvarni));
                        //voltfoglalt=true;
                        int kisebb=0;
                        boolean sorrakerult=false;
                        while(k+varakozik>=kezdet){
                                kezd();
                                
                                
                                sor.seek(0);
                                for(int i=0;i<sorbanalhatnak;i++){
                                    sorbanall[i]=sor.readLong();
                                    if(sorbanall[i]!=0 && sorbanall[i]<sorbanall[enyem])kisebb++;//ellenörizni, hogy elfogytak e már az előttem lévők         ellenorzo[i]=sorbanall[i]; 
                                    
                                }
                                if(kisebb<1){
                                    sorrakerult=true;
                                    break;
                                }
                                
                                else {
                                    list2.remove(7);
                                    list2.add(String.valueOf(kisebb), 7);
                                    kisebb=0;
                                }
                                
                            try {
                                sleep(30000);
                                        
                                        } catch (InterruptedException ex) {
                                Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                                
                            }
                            eletjel();
                                
                        }
                        if(!sorrakerult){
                                //jTextArea1.append("\nA várakozási idő lejártáig nem került sorra a kérés\nkésőbb próbálkozzon újra.");
                                //list2.removeAll();
                                //list2.setBackground(Color.black);
                                sorbolki();
                                kontenerlezar();
                                System.exit(0);
                                return vissza;
                           }else{
                               
                               
                           }
                        list2.removeAll();
                        list2.setBackground(Color.black);
                       try {
                            list1.removeAll();
                            doboz.seek(fejlecpointer);
                            kontfejlecbeolvas();
                        } catch (IOException ex) {
                            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
                        }
        
         }
        return true;
    }

    private void sorbolki() {
        
        try {
            long a=0;
            sor.seek(0);
            for(int i=0;i<sorbanalhatnak;i++){
                if(i!=enyem)a=sor.readLong();
                else sor.writeLong(0);
            }

        } catch (IOException ex) {
            jTextArea1.append("\nSorkilépés...");
            Logger.getLogger(NewApplication.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    
    private void eletjel() throws IOException{
    //jelzem, hogy a sorban elfoglalt helyem valós
    
       
       
        long [] kiolvas=new long[sorbanalhatnak];    
            
        kezd();    
        sor.seek(0);
        
         for(int i=0;i<sorbanalhatnak;i++){
             kiolvas[i]=sor.readLong();
                if(regiek[i]==kiolvas[i]){
                    
                    
                    if((regiek[i]+(1000*60*10))<kezdet){
                       if(!belepo)kiolvas[i]=0; 
                    
                    }
                    
                }
                
            }
         if(kiolvas[enyem]==0){
                        kontenerlezar();
                        System.exit(0);
                    }
         sor.seek(0);
         belepo=false;
         for(int i=0;i<sorbanalhatnak;i++){
             if(i==enyem)sor.writeLong(kiolvas[i]+1);
             else sor.writeLong(kiolvas[i]);
                                    
            }
    }

    private void listaeleme() {
        int sor=list1.getSelectedIndex();
            if(sor<0)return;
            else{
                for(int i=0;i<kontfajlnev.length-1;i++){
                
                    if(list1.getSelectedItem() == null ? kontfajlnev[i] == null : list1.getSelectedItem().equals(kontfajlnev[i])){
                            if(kontflag[i]){
                                String adat=kontfajlnev[i]+" : "+String.valueOf(konpoint[i]/1024)+" Kb, "+String.valueOf(konpoint[i]/1024/1024)+" Mb";
                                jTextArea1.append("\n"+adat);
                                //beleolvas(i);
                                return;
                            }
                        }
                    
                                                        
                    }
                
                
            }
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
                
}
           
                
